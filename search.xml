<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android代码混淆与压缩遇到的坑]]></title>
    <url>%2Fposts%2F48671%2F</url>
    <content type="text"><![CDATA[一、混淆基本知识 Android开发使用Java，为了很好的保护Java源代码，我们需要对编译好后的class文件进行混淆。 ProGuard是一个混淆代码的开源项目，它的主要作用是混淆代码，包括以下4个功能。 压缩(Shrink)：检测并移除代码中无用的类、字段、方法和特性（Attribute）。 优化(Optimize)：对字节码进行优化，移除无用的指令。 混淆(Obfuscate)：使用a，b，c，d这样简短而无意义的名称，对类、字段和方法进行重命名。 预检(Preveirfy)：在Java平台上对处理后的代码进行预检，确保加载的class文件是可执行的。 二、 Android混淆步骤 三步走： 基本混淆 针对APP的量身定制 针对第三方jar包的解决方案 #####1、基本混淆： 开启混淆： 123minifyEnabled trueshrinkResources trueproguardFiles getDefaultProguardFile('proguard-android.txt'),'proguard-rules.pro' #####基本混淆模板 12345678#指定压缩级别-optimizationpasses 5#不跳过非公共的库的类成员-dontskipnonpubliclibraryclassmembers#混淆时采用的算法-optimizations !code/simplification/arithmetic,!field/*,!class/merging/* 12345678910#把混淆类中的方法名也混淆了-useuniqueclassmembernames#优化时允许访问并修改有修饰符的类和类的成员-allowaccessmodification#将文件来源重命名为“SourceFile”字符串-renamesourcefileattribute SourceFile#保留行号-keepattributes SourceFile,LineNumberTable 12345678910111213141516171819#保持所有实现 Serializable 接口的类成员-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125;-keep public class * extends android.app.Activity-keep public class * extends android.app.Application-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.preference.Preference-keep public class * extends android.content.ContentProvider-keep public class * extends android.support.v4.**-keep public class * extends android.support.annotation.**-keep public class * extends android.support.v7.** 12345678# 保持测试相关的代码-dontnote junit.framework.**-dontnote junit.runner.**-dontwarn android.test.**-dontwarn android.support.test.**-dontwarn org.junit.**#保持实体类-keep public class **.*Model*.** &#123;*;&#125; 123456789101112# Only required if you use AsyncExecutor-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent &#123; &lt;init&gt;(Java.lang.Throwable);&#125;#jni方法不混淆-keepclasseswithmembernames class * &#123; # 保持native方法不被混淆 native &lt;methods&gt;;&#125;-keepclassmembers enum * &#123; public static ** values(); public static ** valueOf(java.lang.String);&#125; ######2. 针对APP的量身定制 这部分主要是对实体类及其成员、内部类、WebView、JavaScript、反射的一些处理，针对APP做具体的代码混淆。 ######3、针对第三方jar包的解决方案 一般来说，第三方都会给出自己的混淆配置，拿过来就行 12345678910#okhttp3混淆配置-dontwarn okhttp3.**-keep class okhttp3.** &#123; *;&#125;-dontwarn okio.**#EventBus混淆配置-keepattributes *Annotation*-keepclassmembers class ** &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125; #####遇到的坑： 在做一个项目的时候，发现代码混淆之后，打开APP，直接ANR崩溃，反复查看逻辑，最后发现是SharePerference的坑，SharePerference所依赖的Activity没有keep，导致App运行时找不到，有两种方案，一种是keep SP所在的Activity，或者SP使用生命周期更长的Application.还有就是小伙伴使用360加固，导致使用Activity.SharePerference直接崩。加固有风险，使用需谨慎，有时候，还是手动混淆比较方便一点，混淆关键代码就行了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList源码剖析]]></title>
    <url>%2Fposts%2F43130%2F</url>
    <content type="text"><![CDATA[LinkedList简介LinkedList是基于双向循环链表（从源码中可以很容易看出）实现的，除了可以当作链表来操作外，它还可以当作栈，队列和双端队列来使用。 LinkedList同样是非线程安全的，只在单线程下适合使用。 LinkedList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了Cloneable接口，能被克隆。 LinkedList源码剖析LinkedList的源码如下（加入了比较详细的注释） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639package java.util; public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123; // 链表的表头，表头不包含任何数据。Entry是个链表类数据结构。 private transient Entry&lt;E&gt; header = new Entry&lt;E&gt;(null, null, null); // LinkedList中元素个数 private transient int size = 0; // 默认构造函数：创建一个空的链表 public LinkedList() &#123; header.next = header.previous = header; &#125; // 包含“集合”的构造函数:创建一个包含“集合”的LinkedList public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; // 获取LinkedList的第一个元素 public E getFirst() &#123; if (size==0) throw new NoSuchElementException(); // 链表的表头header中不包含数据。 // 这里返回header所指下一个节点所包含的数据。 return header.next.element; &#125; // 获取LinkedList的最后一个元素 public E getLast() &#123; if (size==0) throw new NoSuchElementException(); // 由于LinkedList是双向链表；而表头header不包含数据。 // 因而，这里返回表头header的前一个节点所包含的数据。 return header.previous.element; &#125; // 删除LinkedList的第一个元素 public E removeFirst() &#123; return remove(header.next); &#125; // 删除LinkedList的最后一个元素 public E removeLast() &#123; return remove(header.previous); &#125; // 将元素添加到LinkedList的起始位置 public void addFirst(E e) &#123; addBefore(e, header.next); &#125; // 将元素添加到LinkedList的结束位置 public void addLast(E e) &#123; addBefore(e, header); &#125; // 判断LinkedList是否包含元素(o) public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125; // 返回LinkedList的大小 public int size() &#123; return size; &#125; // 将元素(E)添加到LinkedList中 public boolean add(E e) &#123; // 将节点(节点数据是e)添加到表头(header)之前。 // 即，将节点添加到双向链表的末端。 addBefore(e, header); return true; &#125; // 从LinkedList中删除元素(o) // 从链表开始查找，如存在元素(o)则删除该元素并返回true； // 否则，返回false。 public boolean remove(Object o) &#123; if (o==null) &#123; // 若o为null的删除情况 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123; if (e.element==null) &#123; remove(e); return true; &#125; &#125; &#125; else &#123; // 若o不为null的删除情况 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123; if (o.equals(e.element)) &#123; remove(e); return true; &#125; &#125; &#125; return false; &#125; // 将“集合(c)”添加到LinkedList中。 // 实际上，是从双向链表的末尾开始，将“集合(c)”添加到双向链表中。 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125; // 从双向链表的index开始，将“集合(c)”添加到双向链表中。 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException("Index: "+index+ ", Size: "+size); Object[] a = c.toArray(); // 获取集合的长度 int numNew = a.length; if (numNew==0) return false; modCount++; // 设置“当前要插入节点的后一个节点” Entry&lt;E&gt; successor = (index==size ? header : entry(index)); // 设置“当前要插入节点的前一个节点” Entry&lt;E&gt; predecessor = successor.previous; // 将集合(c)全部插入双向链表中 for (int i=0; i&lt;numNew; i++) &#123; Entry&lt;E&gt; e = new Entry&lt;E&gt;((E)a[i], successor, predecessor); predecessor.next = e; predecessor = e; &#125; successor.previous = predecessor; // 调整LinkedList的实际大小 size += numNew; return true; &#125; // 清空双向链表 public void clear() &#123; Entry&lt;E&gt; e = header.next; // 从表头开始，逐个向后遍历；对遍历到的节点执行一下操作： // (01) 设置前一个节点为null // (02) 设置当前节点的内容为null // (03) 设置后一个节点为“新的当前节点” while (e != header) &#123; Entry&lt;E&gt; next = e.next; e.next = e.previous = null; e.element = null; e = next; &#125; header.next = header.previous = header; // 设置大小为0 size = 0; modCount++; &#125; // 返回LinkedList指定位置的元素 public E get(int index) &#123; return entry(index).element; &#125; // 设置index位置对应的节点的值为element public E set(int index, E element) &#123; Entry&lt;E&gt; e = entry(index); E oldVal = e.element; e.element = element; return oldVal; &#125; // 在index前添加节点，且节点的值为element public void add(int index, E element) &#123; addBefore(element, (index==size ? header : entry(index))); &#125; // 删除index位置的节点 public E remove(int index) &#123; return remove(entry(index)); &#125; // 获取双向链表中指定位置的节点 private Entry&lt;E&gt; entry(int index) &#123; if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException("Index: "+index+ ", Size: "+size); Entry&lt;E&gt; e = header; // 获取index处的节点。 // 若index &lt; 双向链表长度的1/2,则从前先后查找; // 否则，从后向前查找。 if (index &lt; (size &gt;&gt; 1)) &#123; for (int i = 0; i &lt;= index; i++) e = e.next; &#125; else &#123; for (int i = size; i &gt; index; i--) e = e.previous; &#125; return e; &#125; // 从前向后查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int indexOf(Object o) &#123; int index = 0; if (o==null) &#123; for (Entry e = header.next; e != header; e = e.next) &#123; if (e.element==null) return index; index++; &#125; &#125; else &#123; for (Entry e = header.next; e != header; e = e.next) &#123; if (o.equals(e.element)) return index; index++; &#125; &#125; return -1; &#125; // 从后向前查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int lastIndexOf(Object o) &#123; int index = size; if (o==null) &#123; for (Entry e = header.previous; e != header; e = e.previous) &#123; index--; if (e.element==null) return index; &#125; &#125; else &#123; for (Entry e = header.previous; e != header; e = e.previous) &#123; index--; if (o.equals(e.element)) return index; &#125; &#125; return -1; &#125; // 返回第一个节点 // 若LinkedList的大小为0,则返回null public E peek() &#123; if (size==0) return null; return getFirst(); &#125; // 返回第一个节点 // 若LinkedList的大小为0,则抛出异常 public E element() &#123; return getFirst(); &#125; // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E poll() &#123; if (size==0) return null; return removeFirst(); &#125; // 将e添加双向链表末尾 public boolean offer(E e) &#123; return add(e); &#125; // 将e添加双向链表开头 public boolean offerFirst(E e) &#123; addFirst(e); return true; &#125; // 将e添加双向链表末尾 public boolean offerLast(E e) &#123; addLast(e); return true; &#125; // 返回第一个节点 // 若LinkedList的大小为0,则返回null public E peekFirst() &#123; if (size==0) return null; return getFirst(); &#125; // 返回最后一个节点 // 若LinkedList的大小为0,则返回null public E peekLast() &#123; if (size==0) return null; return getLast(); &#125; // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E pollFirst() &#123; if (size==0) return null; return removeFirst(); &#125; // 删除并返回最后一个节点 // 若LinkedList的大小为0,则返回null public E pollLast() &#123; if (size==0) return null; return removeLast(); &#125; // 将e插入到双向链表开头 public void push(E e) &#123; addFirst(e); &#125; // 删除并返回第一个节点 public E pop() &#123; return removeFirst(); &#125; // 从LinkedList开始向后查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeFirstOccurrence(Object o) &#123; return remove(o); &#125; // 从LinkedList末尾向前查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeLastOccurrence(Object o) &#123; if (o==null) &#123; for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) &#123; if (e.element==null) &#123; remove(e); return true; &#125; &#125; &#125; else &#123; for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) &#123; if (o.equals(e.element)) &#123; remove(e); return true; &#125; &#125; &#125; return false; &#125; // 返回“index到末尾的全部节点”对应的ListIterator对象(List迭代器) public ListIterator&lt;E&gt; listIterator(int index) &#123; return new ListItr(index); &#125; // List迭代器 private class ListItr implements ListIterator&lt;E&gt; &#123; // 上一次返回的节点 private Entry&lt;E&gt; lastReturned = header; // 下一个节点 private Entry&lt;E&gt; next; // 下一个节点对应的索引值 private int nextIndex; // 期望的改变计数。用来实现fail-fast机制。 private int expectedModCount = modCount; // 构造函数。 // 从index位置开始进行迭代 ListItr(int index) &#123; // index的有效性处理 if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException("Index: "+index+ ", Size: "+size); // 若 “index 小于 ‘双向链表长度的一半’”，则从第一个元素开始往后查找； // 否则，从最后一个元素往前查找。 if (index &lt; (size &gt;&gt; 1)) &#123; next = header.next; for (nextIndex=0; nextIndex&lt;index; nextIndex++) next = next.next; &#125; else &#123; next = header; for (nextIndex=size; nextIndex&gt;index; nextIndex--) next = next.previous; &#125; &#125; // 是否存在下一个元素 public boolean hasNext() &#123; // 通过元素索引是否等于“双向链表大小”来判断是否达到最后。 return nextIndex != size; &#125; // 获取下一个元素 public E next() &#123; checkForComodification(); if (nextIndex == size) throw new NoSuchElementException(); lastReturned = next; // next指向链表的下一个元素 next = next.next; nextIndex++; return lastReturned.element; &#125; // 是否存在上一个元素 public boolean hasPrevious() &#123; // 通过元素索引是否等于0，来判断是否达到开头。 return nextIndex != 0; &#125; // 获取上一个元素 public E previous() &#123; if (nextIndex == 0) throw new NoSuchElementException(); // next指向链表的上一个元素 lastReturned = next = next.previous; nextIndex--; checkForComodification(); return lastReturned.element; &#125; // 获取下一个元素的索引 public int nextIndex() &#123; return nextIndex; &#125; // 获取上一个元素的索引 public int previousIndex() &#123; return nextIndex-1; &#125; // 删除当前元素。 // 删除双向链表中的当前节点 public void remove() &#123; checkForComodification(); Entry&lt;E&gt; lastNext = lastReturned.next; try &#123; LinkedList.this.remove(lastReturned); &#125; catch (NoSuchElementException e) &#123; throw new IllegalStateException(); &#125; if (next==lastReturned) next = lastNext; else nextIndex--; lastReturned = header; expectedModCount++; &#125; // 设置当前节点为e public void set(E e) &#123; if (lastReturned == header) throw new IllegalStateException(); checkForComodification(); lastReturned.element = e; &#125; // 将e添加到当前节点的前面 public void add(E e) &#123; checkForComodification(); lastReturned = header; addBefore(e, next); nextIndex++; expectedModCount++; &#125; // 判断 “modCount和expectedModCount是否相等”，依次来实现fail-fast机制。 final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; // 双向链表的节点所对应的数据结构。 // 包含3部分：上一节点，下一节点，当前节点值。 private static class Entry&lt;E&gt; &#123; // 当前节点所包含的值 E element; // 下一个节点 Entry&lt;E&gt; next; // 上一个节点 Entry&lt;E&gt; previous; /** * 链表节点的构造函数。 * 参数说明： * element —— 节点所包含的数据 * next —— 下一个节点 * previous —— 上一个节点 */ Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123; this.element = element; this.next = next; this.previous = previous; &#125; &#125; // 将节点(节点数据是e)添加到entry节点之前。 private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) &#123; // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous); newEntry.previous.next = newEntry; newEntry.next.previous = newEntry; // 修改LinkedList大小 size++; // 修改LinkedList的修改统计数：用来实现fail-fast机制。 modCount++; return newEntry; &#125; // 将节点从链表中删除 private E remove(Entry&lt;E&gt; e) &#123; if (e == header) throw new NoSuchElementException(); E result = e.element; e.previous.next = e.next; e.next.previous = e.previous; e.next = e.previous = null; e.element = null; size--; modCount++; return result; &#125; // 反向迭代器 public Iterator&lt;E&gt; descendingIterator() &#123; return new DescendingIterator(); &#125; // 反向迭代器实现类。 private class DescendingIterator implements Iterator &#123; final ListItr itr = new ListItr(size()); // 反向迭代器是否下一个元素。 // 实际上是判断双向链表的当前节点是否达到开头 public boolean hasNext() &#123; return itr.hasPrevious(); &#125; // 反向迭代器获取下一个元素。 // 实际上是获取双向链表的前一个节点 public E next() &#123; return itr.previous(); &#125; // 删除当前节点 public void remove() &#123; itr.remove(); &#125; &#125; // 返回LinkedList的Object[]数组 public Object[] toArray() &#123; // 新建Object[]数组 Object[] result = new Object[size]; int i = 0; // 将链表中所有节点的数据都添加到Object[]数组中 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) result[i++] = e.element; return result; &#125; // 返回LinkedList的模板数组。所谓模板数组，即可以将T设为任意的数据类型 public &lt;T&gt; T[] toArray(T[] a) &#123; // 若数组a的大小 &lt; LinkedList的元素个数(意味着数组a不能容纳LinkedList中全部元素) // 则新建一个T[]数组，T[]的大小为LinkedList大小，并将该T[]赋值给a。 if (a.length &lt; size) a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), size); // 将链表中所有节点的数据都添加到数组a中 int i = 0; Object[] result = a; for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) result[i++] = e.element; if (a.length &gt; size) a[size] = null; return a; &#125; // 克隆函数。返回LinkedList的克隆对象。 public Object clone() &#123; LinkedList&lt;E&gt; clone = null; // 克隆一个LinkedList克隆对象 try &#123; clone = (LinkedList&lt;E&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; // 新建LinkedList表头节点 clone.header = new Entry&lt;E&gt;(null, null, null); clone.header.next = clone.header.previous = clone.header; clone.size = 0; clone.modCount = 0; // 将链表中所有节点的数据都添加到克隆对象中 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) clone.add(e.element); return clone; &#125; // java.io.Serializable的写入函数 // 将LinkedList的“容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out any hidden serialization magic s.defaultWriteObject(); // 写入“容量” s.writeInt(size); // 将链表中所有节点的数据都写入到输出流中 for (Entry e = header.next; e != header; e = e.next) s.writeObject(e.element); &#125; // java.io.Serializable的读取函数：根据写入方式反向读出 // 先将LinkedList的“容量”读出，然后将“所有的元素值”读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden serialization magic s.defaultReadObject(); // 从输入流中读取“容量” int size = s.readInt(); // 新建链表表头节点 header = new Entry&lt;E&gt;(null, null, null); header.next = header.previous = header; // 从输入流中将“所有的元素值”并逐个添加到链表中 for (int i=0; i&lt;size; i++) addBefore((E)s.readObject(), header); &#125; &#125; ##几点总结 关于LinkedList的源码，给出几点比较重要的总结： 1、从源码中很明显可以看出，LinkedList的实现是基于双向循环链表的，且头结点中不存放数据，如下图; 2、注意两个不同的构造方法。无参构造方法直接建立一个仅包含head节点的空链表，包含Collection的构造方法，先调用无参构造方法建立一个空链表，然后将Collection中的数据加入到链表的尾部后面。 3、在查找和删除某元素时，源码中都划分为该元素为null和不为null两种情况来处理，LinkedList中允许元素为null。 4、LinkedList是基于链表实现的，因此不存在容量不足的问题，所以这里没有扩容的方法。 5、注意源码中的Entry entry(int index)方法。该方法返回双向链表中指定位置处的节点，而链表中是没有下标索引的，要指定位置出的元素，就要遍历该链表，从源码的实现中，我们看到这里有一个加速动作。源码中先将index与长度size的一半比较，如果indexsize/2，就只从位置size往前遍历到位置index处。这样可以减少一部分不必要的遍历，从而提高一定的效率（实际上效率还是很低）。 6、注意链表类对应的数据结构Entry。如下; 1234567891011121314151617181920212223// 双向链表的节点所对应的数据结构。 // 包含3部分：上一节点，下一节点，当前节点值。 private static class Entry&lt;E&gt; &#123; // 当前节点所包含的值 E element; // 下一个节点 Entry&lt;E&gt; next; // 上一个节点 Entry&lt;E&gt; previous; /** * 链表节点的构造函数。 * 参数说明： * element —— 节点所包含的数据 * next —— 下一个节点 * previous —— 上一个节点 */ Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123; this.element = element; this.next = next; this.previous = previous; &#125; &#125; 7、LinkedList是基于链表实现的，因此插入删除效率高，查找效率低（虽然有一个加速动作）。 8、要注意源码中还实现了栈和队列的操作方法，因此也可以作为栈、队列和双端队列来使用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言词法分析程序]]></title>
    <url>%2Fposts%2F58818%2F</url>
    <content type="text"><![CDATA[C语言词法分析程序词法分析原理：词法分析是作为相对独立的阶段来完成的（对源程序或中间结果从头到尾扫描一次，并作相应的加工处理，生成新的中间结果或目标程序）。在词法分析过程中，编译程序是通过操作系统从外部介质中读取源程序文件中的各个字符的。同时，为正确地识别单词，有时还需进行超前搜索和回退字符等操作。因此，为了提高读盘效率和便于扫描器进行工作，通常可采用缓冲输入的方案，即在内存中设置一个适当大小的输入缓冲区，让操作系统直接将磁盘上的源程序字符串分批送入此缓冲区中，供扫描器进行处理。 词法分析程序的一般设计方案是： 程序设计语言词法规则⇒正规文法⇒ FA；或：词法规则⇒正规表达式⇒ FA； NFA确定化⇒ DFA； DFA最简化； 确定单词符号输出形式； 化简后的DFA＋单词符号输出形式⇒构造词法分析程序。 从设计方案可知，要构造词法分析程序，必须掌握以下三个知识点：文法.正规表达式和FA。 文法与语言的形式定义如下： 一个形式文法 G 是下述元素构成的一个元组(VN ，VT ，P，S )。其中： VT —非空有限的终结符号集，即 Σ； 终结符：一个语言不可再分的基本符号。 VN—非空有限的非终结符号集； 非终结符：也称语法变量，用来代表语法范畴。一个非终结符代表一个一定的语法概念，是一个类（集合）记号，而不是一个体记号。 S —开始符号/识别符号，S∈ VN ； P —产生式规则集（或叫规则或生成式或重写规则）； 产生式：形如α → β或α ::= β的表达式，其中α为左部，β为右部。α∈(VT∪VN)+且至少含一个VN；β∈(VT∪VN)*。 VT∪VN =Ф。 仅由字母表A={ai=1，2，…，k}上的正规式α所组成的语言称为正规集，记为L(α)。正规集的形式化描述式称为正规式。 字母表Σ上的正规表达式和正规集递归定义如下： Σ 中的a是正规表达式，其正规集为{a}； 空串ε是Σ上的正规表达式，其正规集为{ε}； 空集Φ是Σ上的正规表达式，其正规集为Φ ； 如果e1和e2是Σ上的正规表达式，它们所表示的正规集分别为L(e1)与L(e2) ，则： e1|e2也是Σ上的正规表达式，其正规集为L(e1|e2)=L(e1) ∪L(e2)。 e1e2也是Σ上的正规表达式，其正规集为L(e1e2)=L(e1) L(e2)。 (e1)* 也是Σ上的正规表达式，其正规集为L((e1)* )=L(e1)*。 而确定有限自动机(DFA)理论定义DFA M=（Q ，Σ ，t ，q0 ，F）。其中： Q —有穷非空状态集； Σ —有穷输入字母表； t — 映射Q × Σ → Q(单值映射，下态确定)； q0 —q0∈Q,称为开始状态(唯一)； F —非空终止状态集； 非确定有限自动机(NFA M) 定义与DFA M的比较可知：NFA可有多个初态，并可能含ε弧或字符串弧；在NFA中，t是多值的，即t（s,a）无法唯一地确定下一状态。 对于FA，最重要的是给出其映射。可以由状态转换表，状态转换图或者直接给出。 直接给出：t(q ,a)=q’； 状态转换表：状态为表列，字母为表行； 3.状态转换图：是由一组矢线连接的有限个结点所组成的有向图。每一结点均代表在识别或分析过程中扫描器所处的状态。它是设计和实现扫描器的一种有效工具，是有限自动机的直观图示。下面是标识符的状态图： （正规式与有限自动机的等价性）定义：对任何两个有限的自动机M1和M2，若有L(M1)=L(M2)，则称M1与M2等价。 可通过子集法或造表法求解NFA的等价DFA（NFA的确定化方法）。 NFA的确定化方法算法（造表法）： 画一张具有n+1列的矩阵表P，n =NFA中出现的符号的个数。各应列的名字分别为I，Ia，Ib，IC，…，其中，a，b，c…是NFA中出的所有字符。 令I = ε－CLOSURE（S0）。S0：NFA的初态集。ε－CLOSURE(S0) = S0∪SεSε= {s| 从S0的某一状态出发经过任意条ε弧可达s} 把I填入乘P的I列 计算Ia，Ib，IC，…，并填入相应的列。Ia = ε－CLOSURE(Ja) Ja = {s | 从I的某一状态出发经过一条a弧可到s} 若J∈{ Ia，Ib，IC，…}未在I列出现，则令I =J。并重复3~5直列所有的J均在I列中出现过。 把P中的各子集作为状态，并重新命名。 确定终态和初态： 初态：I列的第一个元素。 终态：含有原NFA任一终态的子集。 画出相应的DFA 正规文法到有穷自动机的转变步骤： VT ⇒ Σ； VN ⇒ Q,其中S⇒q0； A中增加新状态Z作为终态； U →aV ⇒ t(U，a)=V；  a∈VT或 a=ε，V∈VN 。 U →a (a∈VT) ⇒ t(U,a)=Z。 正规表达式到有穷自动机的转变，对于任意的一个正则表达式e，从开始，按照变换规则，逐步扩弧. 扩结，直到转换图上所有的弧上都是∑中的单个符号为止。对于引入的每一个新状态，应该赋予一个独有的名字。其变换规则如下： 对于一个语言来说，如何对其单词进行分类和编码并没有一个原则性的规定，而主要取决于处理上的方便。通常按照语法分析的需要设置，用整数表示。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337public class Analysis &#123; String sourceFile; //源文件名 String sentence; //程序语句 String word=""; //分析得到的字符串 String keyWord[] = &#123; "if", "int", "for", "while", "do", "return", "break", "continue" &#125;;// 语句控制关键字 String id[]=new String[100]; int idLength=0;//记录标志符表中存放的标志符的个数 String num[]=new String[100]; int numLength=0;//记录常数表中存放的常数的个数 int line=0;//当前读到的行数 //判断是否为数字字符 public boolean isDigit(char ch)&#123; if((ch&gt;='0')&amp;&amp;(ch&lt;='9')) return true; else return false; &#125; //判断是否为字母字符 public boolean isLetter(char ch)&#123; if(((ch&gt;='A')&amp;&amp;(ch&lt;='Z'))||((ch&gt;='a')&amp;&amp;(ch&lt;='z'))) return true; else return false; &#125; //判断是否为关键字 public void isKeyword(String str)&#123; int i=0; for(;i&lt;keyWord.length;i++)&#123; if(str.equals(keyWord[i])) //是关键字 &#123; System.out.println("(关键字："+str+")"); i=keyWord.length;//结束循环，i等于keyWord.length+1 &#125; &#125;//结束循环,i等于keyWord.length if(i==keyWord.length)&#123;//普通标志符 int j=0; for(;j&lt;idLength;j++)&#123;//在标志符表中查找是否有该标志符 if(str.equals(id[j]))//标志符表中已经有该标志符 &#123; System.out.println("(标识符："+str+")");//输出该标志符在标志符表中的位置 j=idLength;//结束循环，j等于idLength+1 &#125; &#125; if(j==idLength)&#123;//标志符表中没有该标志符，将该标志符存入标志符表中，并返回其在符号表中的位置 idLength++;//标志符新增一个 id[idLength-1]=str;//将新标志符存放到标志符表中，索引从0开始 System.out.println("(标识符："+str+")"); &#125; &#125; &#125; //是否为数字 public void isNumber(String str)&#123; int i=0; for(;i&lt;numLength;i++)&#123; if(str.equals(num[i]))&#123; System.out.println("(常量："+str+")"); i=numLength; &#125; &#125; if(i==numLength)&#123; numLength++; num[numLength-1]=str; System.out.println("(常量："+str+")"); &#125; &#125; public void analyse(String str)&#123; char ch;//存放当前字符 char ch2;//存放下一个字符 for(int i=0;i&lt;str.length();i++,word="")&#123; ch=str.charAt(i);//从0索引 if(ch=='\n'||ch=='\t'||ch==' ');//忽略回车、Tab、空格字符 else if(isDigit(ch))&#123; word=word+ch; for(int j=1;j&lt;=str.length()-i;j++)&#123; int k=i+j; if(k==(str.length()+1))&#123;//错误语句，没有;界符 isNumber(word); j=str.length();//跳出循环 i=i+j-1; &#125; else&#123; ch2=str.charAt(k); if(isDigit(ch2)||ch2=='.')&#123; word=word+ch2; &#125; else&#123; isNumber(word); i=i+j-1;//跳过j-1个字符 j=str.length();//跳出循环 &#125; &#125; &#125; &#125; else if(isLetter(ch)||ch=='_')&#123;//变量以字符或者下划线开头 word=word+ch; for(int j=1;j&lt;=str.length()-i;j++)&#123; int k=i+j; if(k==str.length())&#123; isKeyword(word); i=i+j-1; j=str.length();//识别到行尾，跳出循环 &#125; else&#123; ch2=str.charAt(k); if(isLetter(ch2)||isDigit(ch2)||ch2=='_')&#123;//变量由字母、数字或下划线组成 word=word+ch2; &#125; else&#123; isKeyword(word); i=i+j-1;//跳过j-1个字符 j=str.length();//跳出循环，识别下一个单词 &#125; &#125; &#125; &#125; else if(ch=='+')&#123; word=word+ch; ch2=str.charAt(i+1); if(ch2=='=')&#123; System.out.println("(符号： "+ch+ch2+")"); i++; &#125; else&#123; System.out.println("(符号："+ch+")"); &#125; &#125; else if(ch=='-')&#123; word=word+ch; ch2=str.charAt(i+1); if(ch2=='=')&#123; System.out.println("(符号： "+ch+ch2+")"); i++; &#125; else&#123; System.out.println("(符号："+ch+")"); &#125; &#125; else if(ch=='*')&#123; word=word+ch; ch2=str.charAt(i+1); if(ch2=='=')&#123; System.out.println("(符号： "+ch+ch2+")"); i++; &#125; else&#123; System.out.println("(符号："+ch+")"); &#125; &#125; else if(ch=='/')&#123; word=word+ch; ch2=str.charAt(i+1); if(ch2=='=')&#123; System.out.println("(符号： "+ch+ch2+")");//除等/= i++; &#125; else if(ch2=='/')&#123; System.out.print("单行注释\t"); System.out.print("注释内容为："); for(int m=i;m&lt;str.length();m++)&#123; System.out.print(str.charAt(m)); &#125; System.out.println(); i=str.length();//注释行//，读取下一行 &#125; else&#123; System.out.println("(符号："+ch+")"); &#125; &#125; else if(ch=='%')&#123; word=word+ch; ch2=str.charAt(i+1); if(ch2=='=')&#123; System.out.println("(符号： "+ch+ch2+")"); i++; &#125; else&#123; System.out.println("(符号："+ch+")"); &#125; &#125; else if(ch=='&lt;')&#123; word=word+ch; ch2=str.charAt(i+1); if(ch2=='=')&#123; System.out.println("(符号： "+ch+ch2+")"); i++; &#125; else&#123; System.out.println("(符号："+ch+")"); &#125; &#125; else if(ch=='&gt;')&#123; word=word+ch; ch2=str.charAt(i+1); if(ch2=='=')&#123; System.out.println("(符号： "+ch+ch2+")"); i++; &#125; else&#123; System.out.println("(符号："+ch+")"); &#125; &#125; else if(ch=='=')&#123; word=word+ch; ch2=str.charAt(i+1); if(ch2=='=')&#123; System.out.println("(符号： "+ch+ch2+")"); i++; &#125; else&#123; System.out.println("(符号："+ch+")"); &#125; &#125; else if(ch=='!')&#123; word=word+ch; ch2=str.charAt(i+1); if(ch2=='=')&#123; System.out.println("(符号： "+ch+ch2+")"); i++; &#125; else&#123; System.out.println("(符号："+ch+")"); &#125; &#125; else if(ch=='&amp;')&#123; word=word+ch; ch2=str.charAt(i+1); if(ch2=='&amp;')&#123; System.out.println("(符号： "+ch+ch2+")"); i++; &#125; else&#123; System.out.println("非法字符&amp;"); System.out.println("位置："+line+"行"+i+"字符"); &#125; &#125; else if(ch=='|')&#123; word=word+ch; ch2=str.charAt(i+1); if(ch2=='|')&#123; System.out.println("(符号： "+ch+ch2+")"); i++; &#125; else&#123; System.out.println("非法字符|"); System.out.println("位置："+line+"行"+i+"字符"); &#125; &#125; else if(ch=='(')&#123; word=word+ch; System.out.println("(符号："+ch+")"); &#125; else if(ch==')')&#123; word=word+ch; System.out.println("(符号："+ch+")"); &#125; else if(ch=='[')&#123; word=word+ch; System.out.println("(符号："+ch+")"); &#125; else if(ch==']')&#123; word=word+ch; System.out.println("(符号："+ch+")"); &#125; else if(ch=='&#123;')&#123; word=word+ch; System.out.println("(符号："+ch+")"); &#125; else if(ch=='&#125;')&#123; word=word+ch; System.out.println("(符号："+ch+")"); &#125; else if(ch==',')&#123; word=word+ch; System.out.println("(符号："+ch+")"); &#125; else if(ch==';')&#123; word=word+ch; System.out.println("(符号："+ch+")"); &#125; else if(ch=='"')&#123; word=word+ch; System.out.println("(符号："+ch+")"); &#125; else if(ch=='.')&#123; word=word+ch; System.out.println("(符号："+ch+")"); &#125; else&#123; System.out.println("非法字符"+ch); System.out.println("位置："+(line+1)+"行"+(i+1)+"字符"); &#125; &#125; &#125; public static void main(String args[])&#123; Analysis c=new Analysis(); Scanner sc=new Scanner(System.in); System.out.println("请输入您要编译的源程序文件名"); c.sourceFile=sc.next();//输入文件路径、名 try&#123; File f=new File(c.sourceFile);//用指定的文件名构建文件对象 RandomAccessFile raf=new RandomAccessFile(f,"r");//创建文件随机访问 int fileLine=0;//文件行数 while(raf.readLine()!=null)&#123; fileLine++; &#125; System.out.println("源程序共有"+fileLine+"行"); System.out.println("源程序内容为："); raf.seek(0); //从第0个字符开始读取 for(int i=0;i&lt;fileLine;i++)&#123; System.out.println(raf.readLine()); &#125; System.out.println("分析结果为："); raf.seek(0); for(int i=0;i&lt;fileLine;i++)&#123; c.sentence=raf.readLine(); System.out.println("第"+(i+1)+"行："); c.analyse(c.sentence); c.line++; &#125; &#125;catch (IOException e)&#123; System.out.println("文件未找到，请输入正确的文件路径"); &#125;; &#125; &#125;]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HashTable源码剖析]]></title>
    <url>%2Fposts%2F645%2F</url>
    <content type="text"><![CDATA[Hashtable简介 HashTable同样是基于哈希表实现的，同样每个元素都是key-value对，其内部也是通过单链表解决冲突问题，容量不足（超过了阈值）时，同样会自动增长。 Hashtable也是JDK1.0引入的类，是线程安全的，能用于多线程环境中。 Hashtable同样实现了Serializable接口，它支持序列化，实现了Cloneable接口，能被克隆。 ##Hashtable源码剖析Hashtable的源码的很多实现都和HashMap差不多，源码如下（加入了比较详细的注释）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806package java.util; import java.io.*; public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123; // 保存key-value的数组。 // Hashtable同样采用单链表解决冲突，每一个Entry本质上是一个单向链表 private transient Entry[] table; // Hashtable中键值对的数量 private transient int count; // 阈值，用于判断是否需要调整Hashtable的容量（threshold = 容量*加载因子） private int threshold; // 加载因子 private float loadFactor; // Hashtable被改变的次数，用于fail-fast机制的实现 private transient int modCount = 0; // 序列版本号 private static final long serialVersionUID = 1421746759512286392L; // 指定“容量大小”和“加载因子”的构造函数 public Hashtable(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal Load: "+loadFactor); if (initialCapacity==0) initialCapacity = 1; this.loadFactor = loadFactor; table = new Entry[initialCapacity]; threshold = (int)(initialCapacity * loadFactor); &#125; // 指定“容量大小”的构造函数 public Hashtable(int initialCapacity) &#123; this(initialCapacity, 0.75f); &#125; // 默认构造函数。 public Hashtable() &#123; // 默认构造函数，指定的容量大小是11；加载因子是0.75 this(11, 0.75f); &#125; // 包含“子Map”的构造函数 public Hashtable(Map&lt;? extends K, ? extends V&gt; t) &#123; this(Math.max(2*t.size(), 11), 0.75f); // 将“子Map”的全部元素都添加到Hashtable中 putAll(t); &#125; private int hash(Object k) &#123; if (useAltHashing) &#123; if (k.getClass() == String.class) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; else &#123; int h = hashSeed ^ k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; &#125; else &#123; return k.hashCode(); &#125; &#125; public synchronized int size() &#123; return count; &#125; public synchronized boolean isEmpty() &#123; return count == 0; &#125; // 返回“所有key”的枚举对象 public synchronized Enumeration&lt;K&gt; keys() &#123; return this.&lt;K&gt;getEnumeration(KEYS); &#125; // 返回“所有value”的枚举对象 public synchronized Enumeration&lt;V&gt; elements() &#123; return this.&lt;V&gt;getEnumeration(VALUES); &#125; // 判断Hashtable是否包含“值(value)” public synchronized boolean contains(Object value) &#123; //注意，Hashtable中的value不能是null， // 若是null的话，抛出异常! if (value == null) &#123; throw new NullPointerException(); &#125; // 从后向前遍历table数组中的元素(Entry) // 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value Entry tab[] = table; for (int i = tab.length ; i-- &gt; 0 ;) &#123; for (Entry&lt;K,V&gt; e = tab[i] ; e != null ; e = e.next) &#123; if (e.value.equals(value)) &#123; return true; &#125; &#125; &#125; return false; &#125; public boolean containsValue(Object value) &#123; return contains(value); &#125; // 判断Hashtable是否包含key public synchronized boolean containsKey(Object key) &#123; Entry tab[] = table; //计算hash值，直接用key的hashCode代替 int hash = key.hashCode(); // 计算在数组中的索引值 int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return true; &#125; &#125; return false; &#125; // 返回key对应的value，没有的话返回null public synchronized V get(Object key) &#123; Entry tab[] = table; int hash = hash(key); // 计算索引值， int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return e.value; &#125; &#125; return null; &#125; // 调整Hashtable的长度，将长度变成原来的2倍+1 protected void rehash() &#123; int oldCapacity = table.length; Entry[] oldMap = table; //创建新容量大小的Entry数组 int newCapacity = oldCapacity * 2 + 1; Entry[] newMap = new Entry[newCapacity]; modCount++; threshold = (int)(newCapacity * loadFactor); table = newMap; //将“旧的Hashtable”中的元素复制到“新的Hashtable”中 for (int i = oldCapacity ; i-- &gt; 0 ;) &#123; for (Entry&lt;K,V&gt; old = oldMap[i] ; old != null ; ) &#123; Entry&lt;K,V&gt; e = old; old = old.next; //重新计算index int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; e.next = newMap[index]; newMap[index] = e; &#125; &#125; &#125; // 将“key-value”添加到Hashtable中 public synchronized V put(K key, V value) &#123; // Hashtable中不能插入value为null的元素！！！ if (value == null) &#123; throw new NullPointerException(); &#125; // 若“Hashtable中已存在键为key的键值对”， // 则用“新的value”替换“旧的value” Entry tab[] = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; V old = e.value; e.value = value; return old; &#125; &#125; // 若“Hashtable中不存在键为key的键值对”， // 将“修改统计数”+1 modCount++; // 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子) // 则调整Hashtable的大小 if (count &gt;= threshold) &#123; rehash(); tab = table; index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; //将新的key-value对插入到tab[index]处（即链表的头结点） Entry&lt;K,V&gt; e = tab[index]; tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e); count++; return null; &#125; // 删除Hashtable中键为key的元素 public synchronized V remove(Object key) &#123; Entry tab[] = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; //从table[index]链表中找出要删除的节点，并删除该节点。 //因为是单链表，因此要保留带删节点的前一个节点，才能有效地删除节点 for (Entry&lt;K,V&gt; e = tab[index], prev = null ; e != null ; prev = e, e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; modCount++; if (prev != null) &#123; prev.next = e.next; &#125; else &#123; tab[index] = e.next; &#125; count--; V oldValue = e.value; e.value = null; return oldValue; &#125; &#125; return null; &#125; // 将“Map(t)”的中全部元素逐一添加到Hashtable中 public synchronized void putAll(Map&lt;? extends K, ? extends V&gt; t) &#123; for (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet()) put(e.getKey(), e.getValue()); &#125; // 清空Hashtable // 将Hashtable的table数组的值全部设为null public synchronized void clear() &#123; Entry tab[] = table; modCount++; for (int index = tab.length; --index &gt;= 0; ) tab[index] = null; count = 0; &#125; // 克隆一个Hashtable，并以Object的形式返回。 public synchronized Object clone() &#123; try &#123; Hashtable&lt;K,V&gt; t = (Hashtable&lt;K,V&gt;) super.clone(); t.table = new Entry[table.length]; for (int i = table.length ; i-- &gt; 0 ; ) &#123; t.table[i] = (table[i] != null) ? (Entry&lt;K,V&gt;) table[i].clone() : null; &#125; t.keySet = null; t.entrySet = null; t.values = null; t.modCount = 0; return t; &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; &#125; public synchronized String toString() &#123; int max = size() - 1; if (max == -1) return "&#123;&#125;"; StringBuilder sb = new StringBuilder(); Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = entrySet().iterator(); sb.append('&#123;'); for (int i = 0; ; i++) &#123; Map.Entry&lt;K,V&gt; e = it.next(); K key = e.getKey(); V value = e.getValue(); sb.append(key == this ? "(this Map)" : key.toString()); sb.append('='); sb.append(value == this ? "(this Map)" : value.toString()); if (i == max) return sb.append('&#125;').toString(); sb.append(", "); &#125; &#125; // 获取Hashtable的枚举类对象 // 若Hashtable的实际大小为0,则返回“空枚举类”对象； // 否则，返回正常的Enumerator的对象。 private &lt;T&gt; Enumeration&lt;T&gt; getEnumeration(int type) &#123; if (count == 0) &#123; return (Enumeration&lt;T&gt;)emptyEnumerator; &#125; else &#123; return new Enumerator&lt;T&gt;(type, false); &#125; &#125; // 获取Hashtable的迭代器 // 若Hashtable的实际大小为0,则返回“空迭代器”对象； // 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口) private &lt;T&gt; Iterator&lt;T&gt; getIterator(int type) &#123; if (count == 0) &#123; return (Iterator&lt;T&gt;) emptyIterator; &#125; else &#123; return new Enumerator&lt;T&gt;(type, true); &#125; &#125; // Hashtable的“key的集合”。它是一个Set，没有重复元素 private transient volatile Set&lt;K&gt; keySet = null; // Hashtable的“key-value的集合”。它是一个Set，没有重复元素 private transient volatile Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null; // Hashtable的“key-value的集合”。它是一个Collection，可以有重复元素 private transient volatile Collection&lt;V&gt; values = null; // 返回一个被synchronizedSet封装后的KeySet对象 // synchronizedSet封装的目的是对KeySet的所有方法都添加synchronized，实现多线程同步 public Set&lt;K&gt; keySet() &#123; if (keySet == null) keySet = Collections.synchronizedSet(new KeySet(), this); return keySet; &#125; // Hashtable的Key的Set集合。 // KeySet继承于AbstractSet，所以，KeySet中的元素没有重复的。 private class KeySet extends AbstractSet&lt;K&gt; &#123; public Iterator&lt;K&gt; iterator() &#123; return getIterator(KEYS); &#125; public int size() &#123; return count; &#125; public boolean contains(Object o) &#123; return containsKey(o); &#125; public boolean remove(Object o) &#123; return Hashtable.this.remove(o) != null; &#125; public void clear() &#123; Hashtable.this.clear(); &#125; &#125; // 返回一个被synchronizedSet封装后的EntrySet对象 // synchronizedSet封装的目的是对EntrySet的所有方法都添加synchronized，实现多线程同步 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; if (entrySet==null) entrySet = Collections.synchronizedSet(new EntrySet(), this); return entrySet; &#125; // Hashtable的Entry的Set集合。 // EntrySet继承于AbstractSet，所以，EntrySet中的元素没有重复的。 private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return getIterator(ENTRIES); &#125; public boolean add(Map.Entry&lt;K,V&gt; o) &#123; return super.add(o); &#125; // 查找EntrySet中是否包含Object(0) // 首先，在table中找到o对应的Entry链表 // 然后，查找Entry链表中是否存在Object public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry entry = (Map.Entry)o; Object key = entry.getKey(); Entry[] tab = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry e = tab[index]; e != null; e = e.next) if (e.hash==hash &amp;&amp; e.equals(entry)) return true; return false; &#125; // 删除元素Object(0) // 首先，在table中找到o对应的Entry链表 // 然后，删除链表中的元素Object public boolean remove(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); Entry[] tab = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null; prev = e, e = e.next) &#123; if (e.hash==hash &amp;&amp; e.equals(entry)) &#123; modCount++; if (prev != null) prev.next = e.next; else tab[index] = e.next; count--; e.value = null; return true; &#125; &#125; return false; &#125; public int size() &#123; return count; &#125; public void clear() &#123; Hashtable.this.clear(); &#125; &#125; // 返回一个被synchronizedCollection封装后的ValueCollection对象 // synchronizedCollection封装的目的是对ValueCollection的所有方法都添加synchronized，实现多线程同步 public Collection&lt;V&gt; values() &#123; if (values==null) values = Collections.synchronizedCollection(new ValueCollection(), this); return values; &#125; // Hashtable的value的Collection集合。 // ValueCollection继承于AbstractCollection，所以，ValueCollection中的元素可以重复的。 private class ValueCollection extends AbstractCollection&lt;V&gt; &#123; public Iterator&lt;V&gt; iterator() &#123; return getIterator(VALUES); &#125; public int size() &#123; return count; &#125; public boolean contains(Object o) &#123; return containsValue(o); &#125; public void clear() &#123; Hashtable.this.clear(); &#125; &#125; // 重新equals()函数 // 若两个Hashtable的所有key-value键值对都相等，则判断它们两个相等 public synchronized boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof Map)) return false; Map&lt;K,V&gt; t = (Map&lt;K,V&gt;) o; if (t.size() != size()) return false; try &#123; // 通过迭代器依次取出当前Hashtable的key-value键值对 // 并判断该键值对，存在于Hashtable中。 // 若不存在，则立即返回false；否则，遍历完“当前Hashtable”并返回true。 Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); while (i.hasNext()) &#123; Map.Entry&lt;K,V&gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) &#123; if (!(t.get(key)==null &amp;&amp; t.containsKey(key))) return false; &#125; else &#123; if (!value.equals(t.get(key))) return false; &#125; &#125; &#125; catch (ClassCastException unused) &#123; return false; &#125; catch (NullPointerException unused) &#123; return false; &#125; return true; &#125; // 计算Entry的hashCode // 若 Hashtable的实际大小为0 或者 加载因子&lt;0，则返回0。 // 否则，返回“Hashtable中的每个Entry的key和value的异或值 的总和”。 public synchronized int hashCode() &#123; int h = 0; if (count == 0 || loadFactor &lt; 0) return h; // Returns zero loadFactor = -loadFactor; // Mark hashCode computation in progress Entry[] tab = table; for (int i = 0; i &lt; tab.length; i++) for (Entry e = tab[i]; e != null; e = e.next) h += e.key.hashCode() ^ e.value.hashCode(); loadFactor = -loadFactor; // Mark hashCode computation complete return h; &#125; // java.io.Serializable的写入函数 // 将Hashtable的“总的容量，实际容量，所有的Entry”都写入到输出流中 private synchronized void writeObject(java.io.ObjectOutputStream s) throws IOException &#123; // Write out the length, threshold, loadfactor s.defaultWriteObject(); // Write out length, count of elements and then the key/value objects s.writeInt(table.length); s.writeInt(count); for (int index = table.length-1; index &gt;= 0; index--) &#123; Entry entry = table[index]; while (entry != null) &#123; s.writeObject(entry.key); s.writeObject(entry.value); entry = entry.next; &#125; &#125; &#125; // java.io.Serializable的读取函数：根据写入方式读出 // 将Hashtable的“总的容量，实际容量，所有的Entry”依次读出 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the length, threshold, and loadfactor s.defaultReadObject(); // Read the original length of the array and number of elements int origlength = s.readInt(); int elements = s.readInt(); // Compute new size with a bit of room 5% to grow but // no larger than the original size. Make the length // odd if it's large enough, this helps distribute the entries. // Guard against the length ending up zero, that's not valid. int length = (int)(elements * loadFactor) + (elements / 20) + 3; if (length &gt; elements &amp;&amp; (length &amp; 1) == 0) length--; if (origlength &gt; 0 &amp;&amp; length &gt; origlength) length = origlength; Entry[] table = new Entry[length]; count = 0; // Read the number of elements and then all the key/value objects for (; elements &gt; 0; elements--) &#123; K key = (K)s.readObject(); V value = (V)s.readObject(); // synch could be eliminated for performance reconstitutionPut(table, key, value); &#125; this.table = table; &#125; private void reconstitutionPut(Entry[] tab, K key, V value) throws StreamCorruptedException &#123; if (value == null) &#123; throw new java.io.StreamCorruptedException(); &#125; // Makes sure the key is not already in the hashtable. // This should not happen in deserialized version. int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; throw new java.io.StreamCorruptedException(); &#125; &#125; // Creates the new entry. Entry&lt;K,V&gt; e = tab[index]; tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e); count++; &#125; // Hashtable的Entry节点，它本质上是一个单向链表。 // 也因此，我们才能推断出Hashtable是由拉链法实现的散列表 private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // 哈希值 int hash; K key; V value; // 指向的下一个Entry，即链表的下一个节点 Entry&lt;K,V&gt; next; // 构造函数 protected Entry(int hash, K key, V value, Entry&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; protected Object clone() &#123; return new Entry&lt;K,V&gt;(hash, key, value, (next==null ? null : (Entry&lt;K,V&gt;) next.clone())); &#125; public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125; // 设置value。若value是null，则抛出异常。 public V setValue(V value) &#123; if (value == null) throw new NullPointerException(); V oldValue = this.value; this.value = value; return oldValue; &#125; // 覆盖equals()方法，判断两个Entry是否相等。 // 若两个Entry的key和value都相等，则认为它们相等。 public boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; return (key==null ? e.getKey()==null : key.equals(e.getKey())) &amp;&amp; (value==null ? e.getValue()==null : value.equals(e.getValue())); &#125; public int hashCode() &#123; return hash ^ (value==null ? 0 : value.hashCode()); &#125; public String toString() &#123; return key.toString()+"="+value.toString(); &#125; &#125; private static final int KEYS = 0; private static final int VALUES = 1; private static final int ENTRIES = 2; // Enumerator的作用是提供了“通过elements()遍历Hashtable的接口” 和 “通过entrySet()遍历Hashtable的接口”。 private class Enumerator&lt;T&gt; implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; &#123; // 指向Hashtable的table Entry[] table = Hashtable.this.table; // Hashtable的总的大小 int index = table.length; Entry&lt;K,V&gt; entry = null; Entry&lt;K,V&gt; lastReturned = null; int type; // Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志 // iterator为true，表示它是迭代器；否则，是枚举类。 boolean iterator; // 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。 protected int expectedModCount = modCount; Enumerator(int type, boolean iterator) &#123; this.type = type; this.iterator = iterator; &#125; // 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。 public boolean hasMoreElements() &#123; Entry&lt;K,V&gt; e = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (e == null &amp;&amp; i &gt; 0) &#123; e = t[--i]; &#125; entry = e; index = i; return e != null; &#125; // 获取下一个元素 // 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式” // 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。 // 然后，依次向后遍历单向链表Entry。 public T nextElement() &#123; Entry&lt;K,V&gt; et = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (et == null &amp;&amp; i &gt; 0) &#123; et = t[--i]; &#125; entry = et; index = i; if (et != null) &#123; Entry&lt;K,V&gt; e = lastReturned = entry; entry = e.next; return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e); &#125; throw new NoSuchElementException("Hashtable Enumerator"); &#125; // 迭代器Iterator的判断是否存在下一个元素 // 实际上，它是调用的hasMoreElements() public boolean hasNext() &#123; return hasMoreElements(); &#125; // 迭代器获取下一个元素 // 实际上，它是调用的nextElement() public T next() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); return nextElement(); &#125; // 迭代器的remove()接口。 // 首先，它在table数组中找出要删除元素所在的Entry， // 然后，删除单向链表Entry中的元素。 public void remove() &#123; if (!iterator) throw new UnsupportedOperationException(); if (lastReturned == null) throw new IllegalStateException("Hashtable Enumerator"); if (modCount != expectedModCount) throw new ConcurrentModificationException(); synchronized(Hashtable.this) &#123; Entry[] tab = Hashtable.this.table; int index = (lastReturned.hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null; prev = e, e = e.next) &#123; if (e == lastReturned) &#123; modCount++; expectedModCount++; if (prev == null) tab[index] = e.next; else prev.next = e.next; count--; lastReturned = null; return; &#125; &#125; throw new ConcurrentModificationException(); &#125; &#125; &#125; private static Enumeration emptyEnumerator = new EmptyEnumerator(); private static Iterator emptyIterator = new EmptyIterator(); // 空枚举类 // 当Hashtable的实际大小为0；此时，又要通过Enumeration遍历Hashtable时，返回的是“空枚举类”的对象。 private static class EmptyEnumerator implements Enumeration&lt;Object&gt; &#123; EmptyEnumerator() &#123; &#125; // 空枚举类的hasMoreElements() 始终返回false public boolean hasMoreElements() &#123; return false; &#125; // 空枚举类的nextElement() 抛出异常 public Object nextElement() &#123; throw new NoSuchElementException("Hashtable Enumerator"); &#125; &#125; // 空迭代器 // 当Hashtable的实际大小为0；此时，又要通过迭代器遍历Hashtable时，返回的是“空迭代器”的对象。 private static class EmptyIterator implements Iterator&lt;Object&gt; &#123; EmptyIterator() &#123; &#125; public boolean hasNext() &#123; return false; &#125; public Object next() &#123; throw new NoSuchElementException("Hashtable Iterator"); &#125; public void remove() &#123; throw new IllegalStateException("Hashtable Iterator"); &#125; &#125; &#125; ##几点总结 针对Hashtable，我们同样给出几点比较重要的总结，但要结合与HashMap的比较来总结。 二者的存储结构和解决冲突的方法都是相同的。 HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。 Hashtable中key和value都不允许为null，而HashMap中key和value都允许为null（key只能有一个为null，而value则可以有多个为null）。但是如果在Hashtable中有类似put(null,null)的操作，编译同样可以通过，因为key和value都是Object类型，但运行时会抛出NullPointerException异常，这是JDK的规范规定的。我们来看下ContainsKey方法和ContainsValue的源码： 12345678910111213141516171819202122232425262728293031323334353637383940// 判断Hashtable是否包含“值(value)” public synchronized boolean contains(Object value) &#123; //注意，Hashtable中的value不能是null， // 若是null的话，抛出异常! if (value == null) &#123; throw new NullPointerException(); &#125; // 从后向前遍历table数组中的元素(Entry) // 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value Entry tab[] = table; for (int i = tab.length ; i-- &gt; 0 ;) &#123; for (Entry&lt;K,V&gt; e = tab[i] ; e != null ; e = e.next) &#123; if (e.value.equals(value)) &#123; return true; &#125; &#125; &#125; return false; &#125; public boolean containsValue(Object value) &#123; return contains(value); &#125; // 判断Hashtable是否包含key public synchronized boolean containsKey(Object key) &#123; Entry tab[] = table; /计算hash值，直接用key的hashCode代替 int hash = hash(key); // 计算在数组中的索引值 int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return true; &#125; &#125; return false; &#125; 很明显，如果value为null，会直接抛出NullPointerException异常，但源码中并没有对key是否为null判断，有点小不解！不过NullPointerException属于RuntimeException异常，是可以由JVM自动抛出的，也许对key的值在JVM中有所限制吧。 Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。 Hashtable和HashMap都重新计算了key的hash值，Hashtable在求hash值对应的位置索引时，用取模运算，而HashMap在求位置索引时，则用与运算，且这里一般先用hash&amp;0x7FFFFFFF后，再对length取模，&amp;0x7FFFFFFF的目的是为了将负的hash值转化为正值，因为hash值有可能为负数，而&amp;0x7FFFFFFF后，只有符号外改变，而后面的位都不变。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap源码剖析]]></title>
    <url>%2Fposts%2F41456%2F</url>
    <content type="text"><![CDATA[HashMap简介 HashMap是基于哈希表实现的，每一个元素都是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阈值）时，同样会自动增长。 HashMap是非线程安全的，只是用于单线程环境下，多线程环境下可以采用concurrent并发包下的concurrentHashMap。 HashMap实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆。 ###HashMap源码剖析 HashMap的源码如下（加入了比较详细的注释）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754package java.util; import java.io.*; public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; // 默认的初始容量（容量为HashMap中槽的数目）是16，且实际容量必须是2的整数次幂。 static final int DEFAULT_INITIAL_CAPACITY = 16; // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换） static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认加载因子为0.75 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 存储数据的Entry数组，长度是2的幂。 // HashMap采用链表法解决冲突，每一个Entry本质上是一个单向链表 transient Entry[] table; // HashMap的底层数组中已用槽的数量 transient int size; // HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子） int threshold; // 加载因子实际大小 final float loadFactor; // HashMap被改变的次数 transient volatile int modCount; // 指定“容量大小”和“加载因子”的构造函数 public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); // HashMap的最大容量只能是MAXIMUM_CAPACITY if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; //加载因此不能小于0 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); // 找出“大于initialCapacity”的最小的2的幂 int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; // 设置“加载因子” this.loadFactor = loadFactor; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(capacity * loadFactor); // 创建Entry数组，用来保存数据 table = new Entry[capacity]; init(); &#125; // 指定“容量大小”的构造函数 public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; // 默认构造函数。 public HashMap() &#123; // 设置“加载因子”为默认加载因子0.75 this.loadFactor = DEFAULT_LOAD_FACTOR; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR); // 创建Entry数组，用来保存数据 table = new Entry[DEFAULT_INITIAL_CAPACITY]; init(); &#125; // 包含“子Map”的构造函数 public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR); // 将m中的全部元素逐个添加到HashMap中 putAllForCreate(m); &#125; //求hash值的方法，重新计算hash值 static int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; // 返回h在数组中的索引值，这里用&amp;代替取模，旨在提升效率 // h &amp; (length-1)保证返回值的小于length static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; // 获取key对应的value public V get(Object key) &#123; if (key == null) return getForNullKey(); // 获取key的hash值 int hash = hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; //判断key是否相同 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; //没找到则返回null return null; &#125; // 获取“key为null”的元素的值 // HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！ private V getForNullKey() &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) return e.value; &#125; return null; &#125; // HashMap是否包含key public boolean containsKey(Object key) &#123; return getEntry(key) != null; &#125; // 返回“键为key”的键值对 final Entry&lt;K,V&gt; getEntry(Object key) &#123; // 获取哈希值 // HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值 int hash = (key == null) ? 0 : hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; // 将“key-value”添加到HashMap中 public V put(K key, V value) &#123; // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; //将key-value添加到table[i]处 addEntry(hash, key, value, i); return null; &#125; // putForNullKey()的作用是将“key为null”键值对添加到table[0]位置 private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 如果没有存在key为null的键值对，则直接题阿见到table[0]处! modCount++; addEntry(0, null, value, 0); return null; &#125; // 创建HashMap对应的“添加方法”， // 它和put()不同。putForCreate()是内部方法，它被构造函数等调用，用来创建HashMap // 而put()是对外提供的往HashMap中添加元素的方法。 private void putForCreate(K key, V value) &#123; int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); // 若该HashMap表中存在“键值等于key”的元素，则替换该元素的value值 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; e.value = value; return; &#125; &#125; // 若该HashMap表中不存在“键值等于key”的元素，则将该key-value添加到HashMap中 createEntry(hash, key, value, i); &#125; // 将“m”中的全部元素都添加到HashMap中。 // 该方法被内部的构造HashMap的方法所调用。 private void putAllForCreate(Map&lt;? extends K, ? extends V&gt; m) &#123; // 利用迭代器将元素逐个添加到HashMap中 for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123; Map.Entry&lt;? extends K, ? extends V&gt; e = i.next(); putForCreate(e.getKey(), e.getValue()); &#125; &#125; // 重新调整HashMap的大小，newCapacity是调整后的容量 void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; //如果就容量已经达到了最大值，则不能再扩容，直接返回 if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中， // 然后，将“新HashMap”赋值给“旧HashMap”。 Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor); &#125; // 将HashMap中的全部元素都添加到newTable中 void transfer(Entry[] newTable) &#123; Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; Entry&lt;K,V&gt; e = src[j]; if (e != null) &#123; src[j] = null; do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; while (e != null); &#125; &#125; &#125; // 将"m"的全部元素都添加到HashMap中 public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; // 有效性判断 int numKeysToBeAdded = m.size(); if (numKeysToBeAdded == 0) return; // 计算容量是否足够， // 若“当前阀值容量 &lt; 需要的容量”，则将容量x2。 if (numKeysToBeAdded &gt; threshold) &#123; int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1); if (targetCapacity &gt; MAXIMUM_CAPACITY) targetCapacity = MAXIMUM_CAPACITY; int newCapacity = table.length; while (newCapacity &lt; targetCapacity) newCapacity &lt;&lt;= 1; if (newCapacity &gt; table.length) resize(newCapacity); &#125; // 通过迭代器，将“m”中的元素逐个添加到HashMap中。 for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123; Map.Entry&lt;? extends K, ? extends V&gt; e = i.next(); put(e.getKey(), e.getValue()); &#125; &#125; // 删除“键为key”元素 public V remove(Object key) &#123; Entry&lt;K,V&gt; e = removeEntryForKey(key); return (e == null ? null : e.value); &#125; // 删除“键为key”的元素 final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; // 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算 int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; // 删除链表中“键为key”的元素 // 本质是“删除单向链表中的节点” while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e; &#125; // 删除“键值对” final Entry&lt;K,V&gt; removeMapping(Object o) &#123; if (!(o instanceof Map.Entry)) return null; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; Object key = entry.getKey(); int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; // 删除链表中的“键值对e” // 本质是“删除单向链表中的节点” while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; if (e.hash == hash &amp;&amp; e.equals(entry)) &#123; modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e; &#125; // 清空HashMap，将所有的元素设为null public void clear() &#123; modCount++; Entry[] tab = table; for (int i = 0; i &lt; tab.length; i++) tab[i] = null; size = 0; &#125; // 是否包含“值为value”的元素 public boolean containsValue(Object value) &#123; // 若“value为null”，则调用containsNullValue()查找 if (value == null) return containsNullValue(); // 若“value不为null”，则查找HashMap中是否有值为value的节点。 Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (value.equals(e.value)) return true; return false; &#125; // 是否包含null值 private boolean containsNullValue() &#123; Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (e.value == null) return true; return false; &#125; // 克隆一个HashMap，并返回Object对象 public Object clone() &#123; HashMap&lt;K,V&gt; result = null; try &#123; result = (HashMap&lt;K,V&gt;)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; // assert false; &#125; result.table = new Entry[table.length]; result.entrySet = null; result.modCount = 0; result.size = 0; result.init(); // 调用putAllForCreate()将全部元素添加到HashMap中 result.putAllForCreate(this); return result; &#125; // Entry是单向链表。 // 它是 “HashMap链式存储法”对应的链表。 // 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数 static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; // 指向下一个节点 Entry&lt;K,V&gt; next; final int hash; // 构造函数。 // 输入参数包括"哈希值(h)", "键(k)", "值(v)", "下一节点(n)" Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 判断两个Entry是否相等 // 若两个Entry的“key”和“value”都相等，则返回true。 // 否则，返回false public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; // 实现hashCode() public final int hashCode() &#123; return (key==null ? 0 : key.hashCode()) ^ (value==null ? 0 : value.hashCode()); &#125; public final String toString() &#123; return getKey() + "=" + getValue(); &#125; // 当向HashMap中添加元素时，绘调用recordAccess()。 // 这里不做任何处理 void recordAccess(HashMap&lt;K,V&gt; m) &#123; &#125; // 当从HashMap中删除元素时，绘调用recordRemoval()。 // 这里不做任何处理 void recordRemoval(HashMap&lt;K,V&gt; m) &#123; &#125; &#125; // 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。 void addEntry(int hash, K key, V value, int bucketIndex) &#123; // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小 if (size++ &gt;= threshold) resize(2 * table.length); &#125; // 创建Entry。将“key-value”插入指定位置。 void createEntry(int hash, K key, V value, int bucketIndex) &#123; // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); size++; &#125; // HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。 // 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。 private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; // 下一个元素 Entry&lt;K,V&gt; next; // expectedModCount用于实现fast-fail机制。 int expectedModCount; // 当前索引 int index; // 当前元素 Entry&lt;K,V&gt; current; HashIterator() &#123; expectedModCount = modCount; if (size &gt; 0) &#123; // advance to first entry Entry[] t = table; // 将next指向table中第一个不为null的元素。 // 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。 while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; // 获取下一个元素 final Entry&lt;K,V&gt; nextEntry() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); // 注意！！！ // 一个Entry就是一个单向链表 // 若该Entry的下一个节点不为空，就将next指向下一个节点; // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。 if ((next = e.next) == null) &#123; Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; current = e; return e; &#125; // 删除当前元素 public void remove() &#123; if (current == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); Object k = current.key; current = null; HashMap.this.removeEntryForKey(k); expectedModCount = modCount; &#125; &#125; // value的迭代器 private final class ValueIterator extends HashIterator&lt;V&gt; &#123; public V next() &#123; return nextEntry().value; &#125; &#125; // key的迭代器 private final class KeyIterator extends HashIterator&lt;K&gt; &#123; public K next() &#123; return nextEntry().getKey(); &#125; &#125; // Entry的迭代器 private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125; &#125; // 返回一个“key迭代器” Iterator&lt;K&gt; newKeyIterator() &#123; return new KeyIterator(); &#125; // 返回一个“value迭代器” Iterator&lt;V&gt; newValueIterator() &#123; return new ValueIterator(); &#125; // 返回一个“entry迭代器” Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator() &#123; return new EntryIterator(); &#125; // HashMap的Entry对应的集合 private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null; // 返回“key的集合”，实际上返回一个“KeySet对象” public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks = keySet; return (ks != null ? ks : (keySet = new KeySet())); &#125; // Key对应的集合 // KeySet继承于AbstractSet，说明该集合中没有重复的Key。 private final class KeySet extends AbstractSet&lt;K&gt; &#123; public Iterator&lt;K&gt; iterator() &#123; return newKeyIterator(); &#125; public int size() &#123; return size; &#125; public boolean contains(Object o) &#123; return containsKey(o); &#125; public boolean remove(Object o) &#123; return HashMap.this.removeEntryForKey(o) != null; &#125; public void clear() &#123; HashMap.this.clear(); &#125; &#125; // 返回“value集合”，实际上返回的是一个Values对象 public Collection&lt;V&gt; values() &#123; Collection&lt;V&gt; vs = values; return (vs != null ? vs : (values = new Values())); &#125; // “value集合” // Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”， // Values中的元素能够重复。因为不同的key可以指向相同的value。 private final class Values extends AbstractCollection&lt;V&gt; &#123; public Iterator&lt;V&gt; iterator() &#123; return newValueIterator(); &#125; public int size() &#123; return size; &#125; public boolean contains(Object o) &#123; return containsValue(o); &#125; public void clear() &#123; HashMap.this.clear(); &#125; &#125; // 返回“HashMap的Entry集合” public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; return entrySet0(); &#125; // 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象 private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet; return es != null ? es : (entrySet = new EntrySet()); &#125; // EntrySet对应的集合 // EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。 private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return newEntryIterator(); &#125; public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o; Entry&lt;K,V&gt; candidate = getEntry(e.getKey()); return candidate != null &amp;&amp; candidate.equals(e); &#125; public boolean remove(Object o) &#123; return removeMapping(o) != null; &#125; public int size() &#123; return size; &#125; public void clear() &#123; HashMap.this.clear(); &#125; &#125; // java.io.Serializable的写入函数 // 将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws IOException &#123; Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = (size &gt; 0) ? entrySet0().iterator() : null; // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); // Write out number of buckets s.writeInt(table.length); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) if (i != null) &#123; while (i.hasNext()) &#123; Map.Entry&lt;K,V&gt; e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); &#125; &#125; &#125; private static final long serialVersionUID = 362498820763181265L; // java.io.Serializable的读取函数：根据写入方式读出 // 将HashMap的“总的容量，实际容量，所有的Entry”依次读出 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold, loadfactor, and any hidden stuff s.defaultReadObject(); // Read in number of buckets and allocate the bucket array; int numBuckets = s.readInt(); table = new Entry[numBuckets]; init(); // Give subclass a chance to do its thing. // Read in size (number of Mappings) int size = s.readInt(); // Read the keys and values, and put the mappings in the HashMap for (int i=0; i&lt;size; i++) &#123; K key = (K) s.readObject(); V value = (V) s.readObject(); putForCreate(key, value); &#125; &#125; // 返回“HashMap总的容量” int capacity() &#123; return table.length; &#125; // 返回“HashMap的加载因子” float loadFactor() &#123; return loadFactor; &#125; &#125; ###几点总结1、首先要清楚HashMap的存储结构，如下图所示： 图中，紫色部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中。 2、首先看链表中节点的数据结构： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// Entry是单向链表。 // 它是 “HashMap链式存储法”对应的链表。 // 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数 static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; // 指向下一个节点 Entry&lt;K,V&gt; next; final int hash; // 构造函数。 // 输入参数包括"哈希值(h)", "键(k)", "值(v)", "下一节点(n)" Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 判断两个Entry是否相等 // 若两个Entry的“key”和“value”都相等，则返回true。 // 否则，返回false public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; // 实现hashCode() public final int hashCode() &#123; return (key==null ? 0 : key.hashCode()) ^ (value==null ? 0 : value.hashCode()); &#125; public final String toString() &#123; return getKey() + "=" + getValue(); &#125; // 当向HashMap中添加元素时，绘调用recordAccess()。 // 这里不做任何处理 void recordAccess(HashMap&lt;K,V&gt; m) &#123; &#125; // 当从HashMap中删除元素时，绘调用recordRemoval()。 // 这里不做任何处理 void recordRemoval(HashMap&lt;K,V&gt; m) &#123; &#125; &#125; 它的结构元素除了key、value、hash外，还有next，next指向下一个节点。另外，这里覆写了equals和hashCode方法来保证键值对的独一无二。 3、HashMap共有四个构造方法。构造方法中提到了两个很重要的参数：初始容量和加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中槽的数量（即哈希数组的长度），初始容量是创建哈希表时的容量（从构造函数中可以看出，如果不指明，则默认为16），加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 resize 操作（即扩容）。 下面说下加载因子，如果加载因子越大，对空间的利用更充分，但是查找效率会降低（链表长度会越来越长）；如果加载因子太小，那么表中的数据将过于稀疏（很多空间还没用，就开始扩容了），对空间造成严重浪费。如果我们在构造方法中不指定，则系统默认加载因子为0.75，这是一个比较理想的值，一般情况下我们是无需修改的。 另外，无论我们指定的容量为多少，构造方法都会将实际容量设为不小于指定容量的2的次方的一个数，且最大值不能超过2的30次方 4、HashMap中key和value都允许为null。 5、要重点分析下HashMap中用的最多的两个方法put和get。先从比较简单的get方法着手，源码如下： 12345678910111213141516171819202122232425262728// 获取key对应的value public V get(Object key) &#123; if (key == null) return getForNullKey(); // 获取key的hash值 int hash = hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; /判断key是否相同 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; 没找到则返回null return null; &#125; // 获取“key为null”的元素的值 // HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！ private V getForNullKey() &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) return e.value; &#125; return null; &#125; 首先，如果key为null，则直接从哈希表的第一个位置table[0]对应的链表上查找。记住，key为null的键值对永远都放在以table[0]为头结点的链表中，当然不一定是存放在头结点table[0]中。 如果key不为null，则先求的key的hash值，根据hash值找到在table中的索引，在该索引对应的单链表中查找是否有键值对的key与目标key相等，有就返回对应的value，没有则返回null。 put方法稍微复杂些，代码如下： 12345678910111213141516171819202122232425 // 将“key-value”添加到HashMap中 public V put(K key, V value) &#123; // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; //将key-value添加到table[i]处 addEntry(hash, key, value, i); return null; &#125; 如果key为null，则将其添加到table[0]对应的链表中，putForNullKey的源码如下： 123456789101112131415// putForNullKey()的作用是将“key为null”键值对添加到table[0]位置 private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 如果没有存在key为null的键值对，则直接题阿见到table[0]处! modCount++; addEntry(0, null, value, 0); return null; &#125; 如果key不为null，则同样先求出key的hash值，根据hash值得出在table中的索引，而后遍历对应的单链表，如果单链表中存在与目标key相等的键值对，则将新的value覆盖旧的value，比将旧的value返回，如果找不到与目标key相等的键值对，或者该单链表为空，则将该键值对插入到改单链表的头结点位置（每次新插入的节点都是放在头结点的位置），该操作是有addEntry方法实现的，它的源码如下： 1234567891011// 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。 void addEntry(int hash, K key, V value, int bucketIndex) &#123; // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小 if (size++ &gt;= threshold) resize(2 * table.length); &#125; 注意这里倒数第三行的构造方法，将key-value键值对赋给table[bucketIndex]，并将其next指向元素e，这便将key-value放到了头结点中，并将之前的头结点接在了它的后面。该方法也说明，每次put键值对的时候，总是将新的该键值对放在table[bucketIndex]处（即头结点处）。 两外注意最后两行代码，每次加入键值对时，都要判断当前已用的槽的数目是否大于等于阀值（容量*加载因子），如果大于等于，则进行扩容，将容量扩为原来容量的2倍。 6、关于扩容。上面我们看到了扩容的方法，resize方法，它的源码如下： 12345678910111213141516// 重新调整HashMap的大小，newCapacity是调整后的单位 void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中， // 然后，将“新HashMap”赋值给“旧HashMap”。 Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor); &#125; 很明显，是新建了一个HashMap的底层数组，而后调用transfer方法，将就HashMap的全部元素添加到新的HashMap中（要重新计算元素在新的数组中的索引位置）。transfer方法的源码如下： 123456789101112131415161718// 将HashMap中的全部元素都添加到newTable中 void transfer(Entry[] newTable) &#123; Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; Entry&lt;K,V&gt; e = src[j]; if (e != null) &#123; src[j] = null; do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; while (e != null); &#125; &#125; &#125; 很明显，扩容是一个相当耗时的操作，因为它需要重新计算这些元素在新的数组中的位置并进行复制处理。因此，我们在用HashMap的时，最好能提前预估下HashMap中元素的个数，这样有助于提高HashMap的性能。 7、注意containsKey方法和containsValue方法。前者直接可以通过key的哈希值将搜索范围定位到指定索引对应的链表，而后者要对哈希数组的每个链表进行搜索。 8、我们重点来分析下求hash值和索引值的方法，这两个方法便是HashMap设计的最为核心的部分，二者结合能保证哈希表中的元素尽可能均匀地散列。 计算哈希值的方法如下： 1234static int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; 它只是一个数学公式，IDK这样设计对hash值的计算，自然有它的好处，至于为什么这样设计，我们这里不去追究，只要明白一点，用的位的操作使hash值的计算效率很高。 由hash值找到对应索引的方法如下：123static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; 这个我们要重点说下，我们一般对哈希表的散列很自然地会想到用hash值对length取模（即除法散列法），Hashtable中也是这样实现的，这种方法基本能保证元素在哈希表中散列的比较均匀，但取模会用到除法运算，效率很低，HashMap中则通过h&amp;(length-1)的方法来代替取模，同样实现了均匀的散列，但效率要高很多，这也是HashMap对Hashtable的一个改进。 接下来，我们分析下为什么哈希表的容量一定要是2的整数次幂。首先，length为2的整数次幂的话，h&amp;(length-1)就相当于对length取模，这样便保证了散列的均匀，同时也提升了效率；其次，length为2的整数次幂的话，为偶数，这样length-1为奇数，奇数的最后一位是1，这样便保证了h&amp;(length-1)的最后一位可能为0，也可能为1（这取决于h的值），即与后的结果可能为偶数，也可能为奇数，这样便可以保证散列的均匀性，而如果length为奇数的话，很明显length-1为偶数，它的最后一位是0，这样h&amp;(length-1)的最后一位肯定为0，即只能为偶数，这样任何hash值都只会被散列到数组的偶数下标位置上，这便浪费了近一半的空间，因此，length取2的整数次幂，是为了使不同hash值发生碰撞的概率较小，这样就能使元素在哈希表中均匀地散列。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码剖析]]></title>
    <url>%2Fposts%2F33869%2F</url>
    <content type="text"><![CDATA[ArrayList简介 ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长，类似于C语言中的动态申请内存，动态增长内存。 ArrayList不是线程安全的，只能在单线程环境下，多线程环境下可以考虑用collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类，也可以使用concurrent并发包下的CopyOnWriteArrayList类。 ArrayList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了Cloneable接口，能被克隆。 ArrayList源码剖析 ArrayList的源码如下（加入了比较详细的注释）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367package java.util; public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; // 序列版本号 private static final long serialVersionUID = 8683452581122892189L; // ArrayList基于该数组实现，用该数组保存数据 private transient Object[] elementData; // ArrayList中实际数据的数量 private int size; // ArrayList带容量大小的构造函数。 public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); // 新建一个数组 this.elementData = new Object[initialCapacity]; &#125; // ArrayList无参构造函数。默认容量是10。 public ArrayList() &#123; this(10); &#125; // 创建一个包含collection的ArrayList public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; // 将当前容量值设为实际元素个数 public void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; if (size &lt; oldCapacity) &#123; elementData = Arrays.copyOf(elementData, size); &#125; &#125; // 确定ArrarList的容量。 // 若ArrayList的容量不足以容纳当前的全部元素，设置 新的容量=“(原始容量x3)/2 + 1” public void ensureCapacity(int minCapacity) &#123; // 将“修改统计数”+1，该变量主要是用来实现fail-fast机制的 modCount++; int oldCapacity = elementData.length; // 若当前容量不足以容纳当前的元素个数，设置 新的容量=“(原始容量x3)/2 + 1” if (minCapacity &gt; oldCapacity) &#123; Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; //如果还不够，则直接将minCapacity设置为当前容量 if (newCapacity &lt; minCapacity) newCapacity = minCapacity; elementData = Arrays.copyOf(elementData, newCapacity); &#125; &#125; // 添加元素e public boolean add(E e) &#123; // 确定ArrayList的容量大小 ensureCapacity(size + 1); // Increments modCount!! // 添加e到ArrayList中 elementData[size++] = e; return true; &#125; // 返回ArrayList的实际大小 public int size() &#123; return size; &#125; // ArrayList是否包含Object(o) public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; //返回ArrayList是否为空 public boolean isEmpty() &#123; return size == 0; &#125; // 正向查找，返回元素的索引值 public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; // 反向查找，返回元素的索引值 public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; // 反向查找(从数组末尾向开始查找)，返回元素(o)的索引值 public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; // 返回ArrayList的Object数组 public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; // 返回ArrayList元素组成的数组 public &lt;T&gt; T[] toArray(T[] a) &#123; // 若数组a的大小 &lt; ArrayList的元素个数； // 则新建一个T[]数组，数组大小是“ArrayList的元素个数”，并将“ArrayList”全部拷贝到新数组中 if (a.length &lt; size) return (T[]) Arrays.copyOf(elementData, size, a.getClass()); // 若数组a的大小 &gt;= ArrayList的元素个数； // 则将ArrayList的全部元素都拷贝到数组a中。 System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; // 获取index位置的元素值 public E get(int index) &#123; RangeCheck(index); return (E) elementData[index]; &#125; // 设置index位置的值为element public E set(int index, E element) &#123; RangeCheck(index); E oldValue = (E) elementData[index]; elementData[index] = element; return oldValue; &#125; // 将e添加到ArrayList中 public boolean add(E e) &#123; ensureCapacity(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; // 将e添加到ArrayList的指定位置 public void add(int index, E element) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( "Index: "+index+", Size: "+size); ensureCapacity(size+1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; // 删除ArrayList指定位置的元素 public E remove(int index) &#123; RangeCheck(index); modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work return oldValue; &#125; // 删除ArrayList的指定元素 public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; // 快速删除第index个元素 private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; // 从"index+1"开始，用后面的元素替换前面的元素。 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将最后一个元素设为null elementData[--size] = null; // Let gc do its work &#125; // 删除元素 public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; // 便利ArrayList，找到“元素o”，则删除，并返回true。 for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; // 清空ArrayList，将全部的元素设为null public void clear() &#123; modCount++; for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; // 将集合c追加到ArrayList中 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacity(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; // 从index位置开始，将集合c添加到ArrayList public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( "Index: " + index + ", Size: " + size); Object[] a = c.toArray(); int numNew = a.length; ensureCapacity(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; // 删除fromIndex到toIndex之间的全部元素。 protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // Let gc do its work int newSize = size - (toIndex-fromIndex); while (size != newSize) elementData[--size] = null; &#125; private void RangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException( "Index: "+index+", Size: "+size); &#125; // 克隆函数 public Object clone() &#123; try &#123; ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone(); // 将当前ArrayList的全部元素拷贝到v中 v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125; &#125; // java.io.Serializable的写入函数 // 将ArrayList的“容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // 写入“数组的容量” s.writeInt(elementData.length); // 写入“数组的每一个元素” for (int i=0; i&lt;size; i++) s.writeObject(elementData[i]); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; // java.io.Serializable的读取函数：根据写入方式读出 // 先将ArrayList的“容量”读出，然后将“所有的元素值”读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in size, and any hidden stuff s.defaultReadObject(); // 从输入流中读取ArrayList的“容量” int arrayLength = s.readInt(); Object[] a = elementData = new Object[arrayLength]; // 从输入流中将“所有的元素值”读出 for (int i=0; i&lt;size; i++) a[i] = s.readObject(); &#125; &#125; ##几点总结 关于ArrayList的源码，给出几点比较重要的总结： 注意其三个不同的构造方法。无参构造方法构造的ArrayList的容量默认为10，带有Collection参数的构造方法，将Collection转化为数组赋给ArrayList的实现数组elementData。 注意扩充容量的方法ensureCapacity。ArrayList在每次增加元素（可能是1个，也可能是一组）时，都要调用该方法来确保足够的容量。当容量不足以容纳当前的元素个数时，就设置新的容量为旧的容量的1.5倍加1，如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后用Arrays.copyof()方法将元素拷贝到新的数组（详见下面的第3点）。从中可以看出，当容量不够时，每次增加元素，都要将原来的元素拷贝到一个新的数组中，非常之耗时，也因此建议在事先能确定元素数量的情况下，才使用ArrayList，否则建议使用LinkedList。 ArrayList的实现中大量地调用了Arrays.copyof()和System.arraycopy()方法。我们有必要对这两个方法的实现做下深入的了解。 首先来看Arrays.copyof()方法。它有很多个重载的方法，但实现思路都是一样的，我们来看泛型版本的源码： 123public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; return (T[]) copyOf(original, newLength, original.getClass()); &#125; 很明显调用了另一个copyof方法，该方法有三个参数，最后一个参数指明要转换的数据的类型，其源码如下： 12345678public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; &#125; 这里可以很明显地看出，该方法实际上是在其内部又创建了一个长度为newlength的数组，调用System.arraycopy()方法，将原来数组中的元素复制到了新的数组中。 下面来看System.arraycopy()方法。该方法被标记了native，调用了系统的C/C++代码，在JDK中是看不到的，但在openJDK中可以看到其源码。该函数实际上最终调用了C语言的memmove()函数，因此它可以保证同一个数组内元素的正确复制和移动，比一般的复制方法的实现效率要高很多，很适合用来批量处理数组。Java强烈推荐在复制大量数组元素时用该方法，以取得更高的效率。 注意ArrayList的两个转化为静态数组的toArray方法。 第一个，Object[] toArray()方法。该方法有可能会抛出java.lang.ClassCastException异常，如果直接用向下转型的方法，将整个ArrayList集合转变为指定类型的Array数组，便会抛出该异常，而如果转化为Array数组时不向下转型，而是将每个元素向下转型，则不会抛出该异常，显然对数组中的元素一个个进行向下转型，效率不高，且不太方便。 第二个， T[] toArray(T[] a)方法。该方法可以直接将ArrayList转换得到的Array进行整体向下转型（转型其实是在该方法的源码中实现的），且从该方法的源码中可以看出，参数a的大小不足时，内部会调用Arrays.copyOf方法，该方法内部创建一个新的数组返回，因此对该方法的常用形式如下： 1234public static Integer[] vectorToArray2(ArrayList&lt;Integer&gt; v) &#123; Integer[] newText = (Integer[])v.toArray(new Integer[0]); return newText; &#125; 5.ArrayList基于数组实现，可以通过下标索引直接查找到指定位置的元素，因此查找效率高，但每次插入或删除元素，就要大量地移动元素，插入删除元素的效率低。 6.在查找给定元素索引值等的方法中，源码都将该元素的值分为null和不为null两种情况处理，ArrayList中允许元素为null。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[笔记]算法复习笔记---栈、队列、链表（下）]]></title>
    <url>%2Fposts%2F63850%2F</url>
    <content type="text"><![CDATA[链表 链表的数据结构与栈和队列有所不同，栈和队列都是申请一段连续的存储空间，然后按照顺序存储。而链表是一种在物理上非连续、非顺序的存储结构，数组元素的申请是通过每个元素的指针来联系起来的。 链表分为两种：单向链表和双向链表。我们平时说的，一般是指单向链表，链表在每个节点除了存储数据之外，还额外存储两个指针，分别指向前一个节点，和后一个节点。 链表的代码实现： 123456789101112131415161718public class Node &#123; private int data; private Node next; public int getData() &#123; return data; &#125; public void setData(int data) &#123; this.data = data; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node next) &#123; this.next = next; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192public class Link &#123; private int size = 0; private Node first; private Node last; public Link() &#123; &#125; /** * 链表尾部插入 * @param data */ public void addLast(int data) &#123; if (size == 0) &#123; //为空的时候初始化前后元素 fillStart(data); &#125;else &#123; Node node = new Node(); node.setData(data); last.setNext(node); last = node; &#125; size ++; &#125; /** * 链表头部插入 * @param data */ public void addFirst(int data) &#123; if (size == 0) &#123; fillStart(data); &#125;else &#123; Node node = new Node(); node.setData(data); node.setNext(first); first = node; &#125; size ++; &#125; /** * 从链表指定位置后面插入 * @param data 插入的数据 * @param index 下标从0开始 */ public void add(int data,int index) &#123; if (size &gt; index) &#123; if (size == 0) &#123; //为空初始化前后数组 fillStart(data); &#125;else if (index == 0) &#123; addFirst(data); &#125;else if (size == index + 1 ) &#123; addLast(data); &#125;else &#123; Node temp = getIndex(index); Node node = new Node(); node.setData(data); node.setNext(temp.getNext()); temp.setNext(node); size ++; &#125; &#125;else &#123; throw new IndexOutOfBoundsException("链表没有那么长"); &#125; &#125; /** * 删除链表头元素 */ public void removeFirst() &#123; if (size == 0) &#123; throw new IndexOutOfBoundsException("链表没有元素"); &#125;else if (size == 1) &#123; //只剩下一个元素时，需要清除first和last clear(); &#125;else &#123; Node temp = first; first = temp.getNext(); temp = null; size -- ; &#125; &#125; /** * 删除链表尾部元素 */ public void removeLast() &#123; if (size == 0) &#123; throw new IndexOutOfBoundsException("链表没有元素"); &#125;else if (size == 1) &#123; clear(); &#125;else &#123; Node temp = getIndex(size - 2); temp.setNext(null); size --; &#125; &#125; /** * 删除链表中间元素 * @param index */ public void removeMiddle(int index) &#123; if (size == 0) &#123; throw new IndexOutOfBoundsException("链表没有元素"); &#125;else if (size == 1) &#123; clear(); &#125;else &#123; if (index == 0) &#123; removeFirst(); &#125;else if (size == index -1) &#123; removeLast(); &#125;else &#123; Node temp = getIndex(index - 1); Node next = temp.getNext(); temp.setNext(next.getNext()); next = null; size --; &#125; &#125; &#125; public void printAll() &#123; //当然，可以换成 do...while实现 Node temp = first; System.out.println(temp.getData()); for (int i = 0; i &lt; size - 1; i++) &#123; temp = temp.getNext(); System.out.println(temp.getData()); &#125; &#125; private void clear() &#123; first = null; last = null; size = 0; &#125; /** * 获取指定下标元素 * @param index */ public Node getIndex(int index) &#123; Node temp =first; for (int i = 0; i &lt; index; i++) &#123; temp = temp.getNext(); &#125; return temp; &#125; /** * 再链表中插入第一个元素时，头和尾都是一个元素 * @param data */ private void fillStart(int data) &#123; first = new Node(); first.setData(data); last = first; &#125; public int size() &#123; return size; &#125; /** * 反转链表 */ public void reverse() &#123; Node temp = first; last = temp; Node next =first.getNext(); for (int i = 0; i &lt; size - 1; i++) &#123; Node nextNext = next.getNext(); next.setNext(temp); temp = next; next = nextNext; &#125; last.setNext(null); first = temp; &#125; &#125; 123456789101112131415161718192021222324252627282930public class LinkTest &#123; public static void main(String[] args) &#123; Link link = new Link(); link.addFirst(2); link.addFirst(1); link.addLast(4); link.addLast(5); link.add(3, 1);//下标为1的元素之后插入元素 printAllElements(link);//1、2、3、4、5 link.reverse(); printAllElements(link);//5、4、3、2、1 link.printAll();//这样打印效率更高 link.removeFirst(); link.removeLast(); link.removeMiddle(1); printAllElements(link);//去除了头尾之后，剩下3个元素，去除下标为1的元素，只剩下4、2 link.removeFirst(); link.removeFirst(); System.out.println(link.size());//从头部全部移除，链表为空 &#125; private static void printAllElements(Link link) &#123; for (int i = 0; i &lt; link.size(); i++) &#123; System.out.println(link.getIndex(i).getData()); &#125; &#125; &#125; ###链表的性能分析 链表的插入分为三种：头插法、尾插法、中间插。头部，尾部可以直接插入，时间复杂度为O（1）；中间插入需要遍历链表，时间复杂度为O（L），L为链表长度。链表的删除也类似。 链表的头插和头删都是O（1）的时间复杂度，这和栈很像，所以可以用单向链表实现。 哦，还有静态链表。一般来说，静态链表就是使用一段固定长度的数组，其中的每个元素由data（用于记录数据）和cur（指向下一节点）。下面，用代码实现一下： 12345678910111213141516171819202122public class Element &#123; private int data; private int cur; public int getData() &#123; return data; &#125; public void setData(int data) &#123; this.data = data; &#125; public int getCur() &#123; return cur; &#125; public void setCur(int cur) &#123; this.cur = cur; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180public class StaticLinkedList &#123; private Element[] elements; private int head; private int tail; private int unUsed; private int size; /** * 初始化操作 * @param capacity */ public StaticLinkedList(int capacity) &#123; elements = new Element[capacity]; unUsed = 0; for (int i = 0; i &lt; capacity - 1; i++) &#123; elements[i] = new Element(); elements[i].setCur(i + 1); &#125; elements[capacity - 1 ] = new Element(); elements[capacity - 1 ].setCur(-1); &#125; /** * 在链表指定位置插入 * @param data 要出入的值 * @param index 链表位置（不是数组下标） */ public void insert(int data, int index) &#123; if (index == 0) &#123; insertFirst(data); &#125;else if (index == size) &#123; insertLast(data); &#125;else &#123; checkFull(); //获取要插入的元素的前一个元素 Element preElement = get(index); //获取一个未使用的元素作为要插入的元素 Element unUsedElement = elements[unUsed]; //记录要插入元素的下标 int temp = unUsed; //将从备用链表中拿出来的元素的下一个元素的数组下标设为备用链表头 unUsed = unUsedElement.getCur(); //将要插入元素的指针设为原本前一个元素的指针的下标值（链表插入操作） unUsedElement.setCur(preElement.getCur()); //将前一个元素的指针指向插入的元素下标 preElement.setCur(temp); //赋值 unUsedElement.setData(data); //链表长度加一 size ++ ; &#125; &#125; /** * 链表前端插入 * @param data */ public void insertFirst(int data) &#123; checkFull(); Element unUsedElement = elements[unUsed]; int temp = unUsed; unUsed = unUsedElement.getCur(); unUsedElement.setCur(head); unUsedElement.setData(data); head = temp; size ++ ; &#125; /** * 链表尾部插入 * @param data */ public void insertLast(int data) &#123; checkFull(); Element unUsedElement = elements[unUsed]; int temp = unUsed; unUsed = unUsedElement.getCur(); elements[tail].setCur(temp); unUsedElement.setData(data); tail = temp; size ++ ; &#125; /** * 删除头元素 */ public void deleteFirst() &#123; checkFull(); Element deleteElement = elements[head]; int temp = head; head = deleteElement.getCur(); deleteElement.setCur(unUsed); unUsed = temp; size -- ; &#125; /** * 删除尾元素 */ public void deleteLast() &#123; delete(size - 1); &#125; /** * 删除指定位置元素 * @param index */ public void delete(int index) &#123; if (index == 0) &#123; deleteFirst(); &#125;else &#123; checkEmpty(); Element pre = get(index - 1); int del = pre.getCur();//这是数组下标 Element deleteElement = elements[del]; pre.setCur(deleteElement.getCur()); if (index == size - 1) &#123; tail = index -1; &#125; deleteElement.setCur(unUsed); unUsed = del; size -- ; &#125; &#125; private void checkEmpty() &#123; if (size == 0) &#123; throw new IndexOutOfBoundsException("链表为空"); &#125; &#125; /** * 获取链表元素 * @param index 链表第几个元素（不是数组下标） * @return */ public Element get(int index) &#123; checkEmpty(); Element element = elements[head]; for (int i = 0; i &lt; index; i++) &#123; element = elements[element.getCur()]; &#125; return element; &#125; public void printAll() &#123; Element element = elements[head]; System.out.println(element.getData()); for (int i = 1; i &lt; size; i++) &#123; element = elements[element.getCur()]; System.out.println(element.getData()); &#125; &#125; private void checkFull() &#123; if (size == elements .length) &#123; throw new IndexOutOfBoundsException("数组不够长"); &#125; &#125; public int size() &#123; return size; &#125; &#125; 1234567891011121314151617181920public class StaticLinkedListTest &#123; public static void main(String[] args) &#123; StaticLinkedList link = new StaticLinkedList(10); link.insertFirst(2); link.insertFirst(1); link.insertLast(4); link.insertLast(5); link.insert(3, 1);//下标为1的元素之后插入元素 link.printAll();//1、2、3、4、5 link.deleteFirst(); link.deleteLast(); link.delete(1); link.printAll();//一出了头尾之后，剩下3个元素，一处下标为1的元素，只剩下2、4 System.out.println(link.get(1).getData()); link.deleteFirst(); link.deleteFirst(); System.out.println(link.size());//从头部全部移除，链表为空 &#125;&#125;]]></content>
      <categories>
        <category>Java 数据结构</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[笔记]算法复习笔记---栈、队列、链表（中）]]></title>
    <url>%2Fposts%2F45409%2F</url>
    <content type="text"><![CDATA[一、用两个栈来实现队列 方法：入队都在Stack1中操作，出队都在Stack2中进行，入队和出队的规则如下：入队：直接把元素压入Stack1中。出队：如果Stack2不为空，直接弹出stack2的元素，如果stack2为空，将stack1中所有元素倒入stack2，然后弹出stack2栈顶元素。如果两个队列都空，队列为空队，无法出栈。 12345678910111213141516171819202122232425262728293031323334353637public class Stack2Queue &#123; private Stack stack1; private Stack stack2; private int maxLength; public Stack2Queue( int capacity) &#123; maxLength = capacity; stack1 = new Stack(capacity); stack2 = new Stack(capacity); &#125; public boolean put(int item) &#123; if (stack1.isFull() || maxLength == size()) &#123; //满了 return false; &#125; stack1.push(item); return true; &#125; public int poll() &#123; if (!stack2.isEmpty()) &#123; return stack2.pop(); &#125;else &#123; while (!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; return stack2.pop(); &#125; &#125; public int size() &#123; return stack1.size() + stack2.size(); &#125;&#125; 1234567891011121314public class Stack2QueueTest &#123; public static void main(String[] args) &#123; Stack2Queue queue = new Stack2Queue(5); queue.put(1); queue.put(2); System.out.println(queue.poll());//1 queue.put(3); queue.put(4); System.out.println(queue.poll());//2 System.out.println(queue.poll());//3,这次操作中，把3，4两个元素从stack1倒入stack2 &#125;&#125; ##二、两个队列实现栈 方案： 入栈：两个队列那个不为空，就把元素入队到那个队列中；如果都为空，则任选一个入队，假设这个队列为queue1 出栈：把不为空的队列去除最后一个元素外的所有元素移动到另一个队列中，然后出队最后一个元素。 下面是实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Queue2Stack &#123; private ArrayQueue queue1; private ArrayQueue queue2; private int maxLength; public Queue2Stack(int capacity) &#123; maxLength = capacity; queue1 = new ArrayQueue(capacity); queue2 = new ArrayQueue(capacity); &#125; /** * 入栈 * @param item * @return 入栈结果 */ public boolean push(int item) &#123; if (size() == maxLength) &#123; return false; &#125; if (queue2.isEmpty()) &#123; queue1.put(item); &#125;else&#123; queue2.put(item); &#125; return true; &#125; public Object pop() &#123; if (size() == 0) &#123; throw new IndexOutOfBoundsException("栈里空了"); &#125;else&#123; if (queue2.isEmpty()) &#123; while (queue1.Size() &gt; 1) &#123; queue2.put(queue1.poll()); &#125; return queue1.poll(); &#125;else&#123; while (queue2.Size() &gt; 1) &#123; queue1.put(queue2.poll()); &#125; return queue2.poll(); &#125; &#125; &#125; public int size() &#123; return queue1.Size() + queue2.Size(); &#125;&#125; 1234567891011121314public class Queue2StackTest &#123; public static void main(String[] args) &#123; Queue2Stack stack = new Queue2Stack(5); stack.push(1); stack.push(2); System.out.println(stack.pop());//2 stack.push(3); stack.push(4); System.out.println(stack.pop());//4 System.out.println(stack.pop());//3 &#125;&#125;]]></content>
      <categories>
        <category>Java 数据结构</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[笔记]算法复习笔记---栈、队列、链表（上）]]></title>
    <url>%2Fposts%2F1387%2F</url>
    <content type="text"><![CDATA[一、什么是栈栈，又叫做堆栈（Stack），但是它和堆没有关系。实际上堆和栈是两种不同的概念，栈是一种只能在一端进行插入和删除的线性数据结构。 栈的特点：先进先出（LIFO，Last In First Out），也可以说是先进后出（FILO，First In Last Out），我们只能从一端去操作元素。 一般来说，栈主要有两种操作：一个是进栈（Push），又叫做入栈，压栈；另一个是出栈（POP），或者叫退栈。 我们可以用数组去实现一个简单的栈，在下面栈的实现代码中，以整型元素为例，在Java等高级语言中，数据类型中，可以换成对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class Stack &#123; private int size = 0; private int[] array; public Stack() &#123; this(10); &#125; public Stack(int init) &#123; if (init &lt;= 0) &#123; init = 10; &#125; array = new int[init]; &#125; /** * 入栈 * @param item 入栈元素 */ public void push(int item) &#123; if (size == array.length) &#123; array = Arrays.copyOf(array, size*2); &#125; array[size++] = item; &#125; /** * 获取栈顶元素，但是没有出栈 * @return 栈顶元素 */ public int peek() &#123; if (size ==0) &#123; throw new IndexOutOfBoundsException("栈里已经为空"); &#125; return array[size -1]; &#125; /** * 出栈，同时获取栈顶元素 * @return 栈顶元素 */ public int pop() &#123; int item = peek(); size --; return item; &#125; /** * 栈是否满了？ * @return */ public boolean isFull() &#123; return size == array.length; &#125; /** *栈是否为空栈 ？ * @return */ public boolean isEmpty() &#123; return size ==0; &#125; public int size() &#123; return size; &#125; &#125; 1234567891011121314151617181920public class StackTest &#123; public static void main(String[] args) &#123; Stack stack = new Stack(1); stack.push(1); stack.push(2); System.out.println(stack.size());//栈内元素个数为2，当前数组长度也为2 stack.push(3); System.out.println(stack.size());//栈内元素个数为3，当前数组长度为4 System.out.println(stack.peek());//获取栈顶元素为3，但没有出栈 System.out.println(stack.size());//元素个数还为3 System.out.println(stack.pop());//栈顶元素出栈，返回3 System.out.println(stack.pop());//栈顶元素出栈，返回2 System.out.println(stack.size());//两次出栈之后，当前元素个数为1 &#125;&#125; ###栈的适用场景 逆序输出 由于栈有先进先出的特点，把元素顺序入栈，然后顺序出栈，就可以轻松得到逆序输出。 语法检查，符号成对出现 在编程语言中，{ } [ ] ( ) &lt; &gt; 等都是成对出现的，当遇到符号的前半部分，就进行入栈操作（PUSH），当遇到后半部分就与栈顶元素匹配（PEEK），如果相匹配，就出栈（POP），否则匹配出错。 数值转换 我们在进行数值转换时，最后的商需要逆序输出，用栈就可以简单的实现。当然，栈还有许多应用，比如经常听到的“函数栈”就是我们在调用方法时，计算机会执行PUSH方法，记录调用，在return的时候。就是在方法结束后，执行POP方法，完成前后对应。 二、什么是队列队列也是一种操作受限的数据结构，插入操作只能从一端进行，这个叫队尾，移除操作只能从另一端操作，这个叫队头。 一般来说，队列的实现方式有两种，数组和链表。数组来实现有两种方式：顺序队列和循环队列。用数组实现队列，若出现队满的情况，当有新的元素需要入队的时候，可是没有位置，这时候，要么丢掉，不管它，要么等待，等待时间由程序来控制。 实现顺序队列： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class ArrayQueue &#123; private final Object[] items; private int head = 0; private int tail = 0; /** * 初始化队列 * @param capacity 队列长度 */ public ArrayQueue(int capacity) &#123; this.items = new Object[capacity]; &#125; /** * 入队 * @param item * @return */ public boolean put(Object item) &#123; if (head == ((tail + 1) % items.length)) &#123; //说明队满 return false; &#125; items[tail] = item; tail = (tail + 1) % items.length; //tail标记后移一位 return true; &#125; /** * 获取队列头元素，不出队 * @return */ public Object peek() &#123; if (head == tail) &#123; //s说明对空 return null; &#125; return items[head]; &#125; /** * 出队 * @return */ public Object poll() &#123; if (head == tail) &#123; //说明队空 return null; &#125; Object item = items[head]; items[head] = null;//没用的元素赋空值，当然不设置也可以，反正标记移动之后会被覆盖 head = (head +1 ) % items.length;//head标记后移一位 return item; &#125; public boolean isFull() &#123; return head == (tail + 1) % items.length; &#125; public boolean isEmpty() &#123; return head == tail; &#125; public int Size() &#123; if (tail &gt;= head) &#123; return tail - head; &#125;else &#123; return tail + items.length - head; &#125; &#125;&#125; 1234567891011121314151617181920212223public class ArrayQueueTest &#123; public static void main(String[] args) &#123; ArrayQueue queue = new ArrayQueue(4); System.out.println(queue.put("A"));//true System.out.println(queue.put("B"));//true System.out.println(queue.put("C"));//true System.out.println(queue.put("D"));//false System.out.println(queue.isFull());//true,队列已经满了，队列长度为4，因为是循环队列，最大存3个元素 System.out.println(queue.Size());//3 System.out.println(queue.peek());//A 获取队头元素，不出队 System.out.println(queue.poll());//A System.out.println(queue.poll());//B System.out.println(queue.poll());//C System.out.println(queue.isEmpty());//true ,当前队列为空 &#125;&#125; ###队列的适用场景： 买东西，秒杀 我们很容易想到这个场景，从网购秒杀商品，到排队买早餐。先进先出，先来先走 生产者和消费者模式 还记得生产者和消费者模式吗? 生产者负责生产，生产之后放到传送带，消费者拿下来，这个模式实现起来，无非就是存在一个队列，若干个生产者向队列增加元素，若干个消费者从队列中获取元素。]]></content>
      <categories>
        <category>Java 数据结构</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[笔记]算法复习笔记---数组、集合、散列表（下）]]></title>
    <url>%2Fposts%2F30388%2F</url>
    <content type="text"><![CDATA[散列表是一种空间换时间的数据结构，在算法中提升效率的一种常用的方法。但是，正如其特点，有时候所消耗的空间，真让人头疼，用的时候在二者之间权衡。 散列表，又叫哈希表（HashTable），是能够通过给定的关键字的值直接访问到具体对应值的数据结构。也就是说，把关键字映到一个表中的位置来直接访问记录，以加快访问速度。 通常，我们通过Key来找Value，也就是说，通过Key访问一个映射表来得到Value的地址。而这个映射表，也叫作散列函数或者哈希函数，存放记录的数组叫做散列表。 如果可以通过不同的Key访问到同一个Value，那么就发生了碰撞，我们需要的是通过一个Key可以访问到唯一的Value。 常用的处理冲突的方法有： 开放地址法（开放寻址法） 就是当这个key通过哈希函数找到存放value地址的位置，当这个位置已经存放数据，就存在其紧跟着后面没有占用的位置，如果超过了最大长度，对最大长度取余，这里移动的地址是产生冲突的偏移量。 再哈希法 产生冲突后，用关键字其他部分继续计算地址，直到不产生冲突，当这种方法增加了时间。 链地址法 当产生冲突，把处于同一地址的数据做成一个链表，这种方法最常见。 建立公共溢出区 建立一个公共溢出区，把产生冲突的新地址放在这个公共溢出区里。 ###散列表的特点： 访问速度快 由于散列表有散列函数，把Key映射到一个地址上，访问key对映的Value时候，不需要查找，直接跳到那个地址，因此，散列表的增删改查等任何操作，速度都比较快。 需要额外的空间 当发生冲突，需要额外的空间去存储，空间换时间，有舍才有得。 无序 为了快速找到访问的元素，根据散列函数直接找到存储地址，访问速度就快起来，但是有序访问没有办法实现。 可能产生碰撞 没有完美的散列函数，无论如何总会产生冲突，采用冲突的处理办法，就会使散列表变得更加复杂。 下面展示如何实现一个散列表，这里用数组代替散列表元素（在在真实情况下，大多数语言的实现中，大多数元素都是一个特别的数组，每个元素对应一个地址），每个数组元素作为一个地址。 1234567891011121314public class Entry &#123; int key; int value; Entry next; public Entry(int key, int value, Entry next) &#123; super(); this.key = key; this.value = value; this.next = next; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151public class HashTable &#123; /** * 默认散列表的初始长度 * 设置小一点，这样扩容的时候看的清楚 * 在实际使用中其实可以在初始化传参数，因为扩容是很消耗性能的 */ private static final int DEFAULT_INITIAL_CAPACITY = 4; /** * 扩容因子 */ private static final float LOAD_FACTOR = 0.75f; /** * 散列表数组 */ private Entry[] table = new Entry[DEFAULT_INITIAL_CAPACITY]; private int size = 0; private int use = 0; public void put(int key, int value) &#123; int index = hash(key); if (table[index] == null) &#123; table[index] = new Entry(-1, -1, null); &#125; Entry e = table[index]; if (e.next == null) &#123; //不存在的值，向链表中添加，有可能扩容，要用table属性 table[index].next = new Entry(key, value, null); size++; use++; //不存在的值，说明是个未用过的地址，需要判断是否扩容 if (use &gt;= table.length * LOAD_FACTOR) &#123; resize(); &#125; &#125;else &#123; //本身存在的值，修改已有的值 for (e = e.next; e != null; e =e.next) &#123; int k = e.key; if (k == key) &#123; e.value = value; return; &#125; &#125; //不存在相同的值，直接向链表中添加元素 Entry temp = table[index].next; Entry newEntry = new Entry(key, value, temp); table[index].next = newEntry; size ++; &#125; &#125; /** * 删除 * @param key */ public void remove( int key) &#123; int index = hash(key); Entry e = table[index]; Entry pre = table[index]; if (e != null &amp;&amp; e.next !=null) &#123; for(e = e.next ; e != null; pre = e, e = e.next)&#123; int k = e.key; if (k == key) &#123; pre.next = e.next; size --; return; &#125; &#125; &#125; &#125; /** * 获取 */ public int get(int key) &#123; int index = hash(key); Entry e = table[index]; if (e != null &amp;&amp; e.next != null) &#123; for (int i = 0; i &lt; table.length; i++) &#123; for (e = e.next; e != null; e =e.next) &#123; int k = e.key; if (k == key) &#123; return e.value; &#125; &#125; &#125; &#125; return -1; &#125; /** * 获取散列表中元素的个数 */ public int size() &#123; return size; &#125; /** * 本身散列表是不该有这个方法的，在这里只是为了清楚地看到确实扩容了。 * @return */ public int getLength() &#123; return table.length; &#125; /** * 根据key，通过哈希函数获取位于散列表数组中的哪个位置 * @param key * @return */ public int hash(int key) &#123; return key % table.length; &#125; /** * 扩容 */ public void resize() &#123; int newLength = table.length * 2; Entry[] oldTable = table; table = new Entry[newLength]; use =0; for (int i = 0; i &lt; oldTable.length; i++) &#123; if (oldTable[i] != null &amp;&amp; oldTable[i].next != null) &#123; Entry entry = oldTable[i]; while (null != entry.next) &#123; Entry next = entry.next; //重新计算哈希值，放入新的地址 int index = hash(next.key); if (table[index] == null) &#123; use ++; table[index] = new Entry(-1, -1, null); &#125; table[index].next = new Entry(next.key, next.value, table[index].next); //可以用下面三行代替// Entry temp = table[index].next;// Entry newEntry = new Entry(next.key, next.value, temp);// table[index].next = newEntry; entry = next; &#125; &#125; &#125; &#125; &#125; 123456789101112131415161718192021public class HashTableTest &#123; public static void main(String[] args) &#123; HashTable hashTable = new HashTable(); hashTable.put(1, 10); hashTable.put(2, 20); hashTable.put(5, 50);//和key为1的元素落在一个散列地址上了，实际使用长度为2 System.out.println(hashTable.getLength());//散列表长度为4 hashTable.put(3, 30);//总长度为4，加上该元素后长度就 大于等于3 了，所以扩容 System.out.println(hashTable.getLength());//散列表长为8 //在扩容后4个元素又分别落在不同的地址上 hashTable.put(6, 60);//使用第5 个地址 hashTable.put(7, 70);//使用第6个地址，为8的0.75倍，又需要扩容 System.out.println(hashTable.getLength());//散列表长度为16 System.out.println(hashTable.get(1));//10 System.out.println(hashTable.get(3));//30 System.out.println(hashTable.get(5));//50 System.out.println(hashTable.get(6));//60 &#125;&#125;]]></content>
      <categories>
        <category>Java 数据结构</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[笔记]算法复习笔记---数组、集合、散列表（上）]]></title>
    <url>%2Fposts%2F35509%2F</url>
    <content type="text"><![CDATA[数组是数据结构中最基础的存储方式之一，集合是数组的延伸，散列表，又称哈希表（Hash Table），许多高级语言中都是在数组的基础上实现的，当然还有其他实现形式。 一、数组的特点：1、定长 数组的的长度是固定的，数组的长度在声明时候已经确定，在使用的时候发现不够用，只能重新声明一个数组 2、按照顺序访问 在访问数组中某一个元素的时候，只能从第一个元素按照顺序访问，知道访问到指定位置的元素。虽然在写程序时候可以通过下标直接访问指定位置的元素，但计算机实际上还是按照顺序访问的。 二、升级版数组——集合数组的致命缺点就是长度固定，如果我们一开始不确定，就变得很麻烦了。有可能你会说，那就来个动态的呗，动态数组，在C语言中有一种实现动态数组的方式，就是用Malloc函数动态开辟内存空间， 但在这里我要说的是另一种方式，集合。 什么是集合？ 我的理解就是长度可变的列表（动态数组） 下面这些都是集合： 列表：一般的有序集合，特点是没有顺序，比如链表、队列、栈。 集：一般是无序的集合，特点就是没有顺序不能重复，多数语言都是散列表实现的，支持对集合进行添加、删除、查找等操作。 多重集：一般是无序的集合，但是数据可以有重复的值，支持对集进行添加、删除、查找包含、查找一个元素 在集合中的个数等操作。多重集通过排序可以转换为列表。 关联数组：多数语言也是用散列表实现的，就是可以通过键（key）获取到值（value）。也是没有顺序的 树、图：树、图 同样是集合 ###那集合是怎么实现的呢？ 既然集合是长度可变的数组，那么我们就可以用数组实现集合。 下面，用ArrayList实现简单的集合，也可以叫它变长数组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class ArrayList &#123; private static final int INITIAL_SIZE = 10; private int size = 0; private int[] array; public ArrayList() &#123; array = new int[INITIAL_SIZE]; &#125; public ArrayList(int initial)&#123; if (initial &lt;= 0) &#123; initial = INITIAL_SIZE; &#125; array = new int[INITIAL_SIZE]; &#125; /** * 添加一个元素 * @param num */ public void add(int num) &#123; if (size == array.length) &#123; array = Arrays.copyOf(array, size*2); &#125; array[size++] = num; &#125; /** * 获取指定位置的元素值 * @param i */ public int get(int i) &#123; if (i &gt;= size) &#123; throw new IndexOutOfBoundsException("获取的元素位置超过了最大长度"); &#125; return array[i]; &#125; /** * 设置指定位置的元素值 * @param i * @param num * @return 指定的这个位置 之前的值 */ public int set(int i,int num) &#123; int oldNum = get(i); array[i] = num; return oldNum; &#125; /** * 获取变长数组的长度 * @return */ public int size() &#123; return size; &#125; &#125; 12345678910111213141516171819public class ArrayListTest &#123; public static void main(String[] args) &#123; ArrayList arrayList = new ArrayList(1); arrayList.add(1); arrayList.add(2); arrayList.add(3); arrayList.add(4); arrayList.add(5); System.out.println(arrayList.get(3));//获取数组下标为3的值，也就是第4个位置的值，打印4 arrayList.set(3, 9);//设置第4个位置的值为9 System.out.println(arrayList.get(3));//再次获取，这次打印9 System.out.println(arrayList.size());//变长数组的长度为5，实际上内部数组长度为8，在add（2）和add（5）时，分别进行了长度翻倍和数组复制 &#125; &#125; ###集合的特点： 集合的特点，跟它的实现有关，那就是变长，变长是相对而言，内部还是通过数组实现的，只是在不够用的时候根据策略生成一个更长的数组，把旧数组复制到新数组里。 在正常情况下，会有两个系统开销，一个是数组总是比我们实际使用的长度长，因此存在空间浪费，另一个是数组不够长的时候，需要新建一个更长的数组，同时把旧数组的数据复制到新数组中，这个操作比较消耗系统的性能。3. ###数组与变长数组的性能 虽然集合这个变长数组比普通数组更高级一些，但本质上还是基于数组实现的，所以和数组的性能差不多。 对数组的操作，并不是我们看到的那么直观，计算机需要根据我们的操作寻找指定位置，在数组中添加元素，修改元素，获取元素的时间复杂度都是O(n). 变长数组也有性能损耗的情况，在插入元素时发现其中固定数组的长度不够用，需要新建数组，复制数据，这个过程中会有性能损耗。]]></content>
      <categories>
        <category>Java 数据结构</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
</search>